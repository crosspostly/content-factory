name: Auto-Fix Agent

on:
  workflow_run:
    workflows: ["Generate Content (Part 1 MVP)", "test"]
    types: [completed]

jobs:
  analyze-failure:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}
    permissions:
      contents: write
      actions: read
      issues: write
      pull-requests: write
    
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Get workflow run details
        id: workflow
        run: |
          echo "workflow_name=${{ github.event.workflow_run.name }}" >> $GITHUB_OUTPUT
          echo "workflow_id=${{ github.event.workflow_run.id }}" >> $GITHUB_OUTPUT
          echo "run_number=${{ github.event.workflow_run.run_number }}" >> $GITHUB_OUTPUT
          echo "head_branch=${{ github.event.workflow_run.head_branch }}" >> $GITHUB_OUTPUT
          echo "head_sha=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_OUTPUT
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          pip install google-generativeai requests pyyaml pandas
      
      - name: Fetch GitHub Actions logs
        id: logs
        run: |
          python3 << 'PYTHON_SCRIPT'
          import subprocess
          import os
          
          # Get workflow run logs
          workflow_id = "${{ steps.workflow.outputs.workflow_id }}"
          
          # Use gh CLI to get logs
          result = subprocess.run(
              ["gh", "run", "view", workflow_id, "--log"],
              capture_output=True,
              text=True,
              env={**os.environ, "GH_TOKEN": "${{ github.token }}"}
          )
          
          logs = result.stdout + result.stderr
          
          # Save to file
          with open("/tmp/workflow_logs.txt", "w") as f:
              f.write(logs)
          
          # Extract error section
          lines = logs.split("\n")
          error_lines = []
          capture = False
          for line in lines:
              if "error" in line.lower() or "failed" in line.lower() or capture:
                  error_lines.append(line)
                  capture = True
              if capture and len(error_lines) > 100:
                  break
          
          error_summary = "\n".join(error_lines[-50:])
          
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"error_summary<<EOF\n{error_summary}\nEOF\n")
          
          PYTHON_SCRIPT
      
      - name: Analyze with Gemini 2.5
        id: gemini
        run: |
          python3 << 'PYTHON_SCRIPT'
          import google.generativeai as genai
          import os
          import json
          
          api_key = "${{ secrets.GOOGLE_AI_API_KEY }}"
          if not api_key:
              print("ERROR: GOOGLE_AI_API_KEY not set")
              exit(1)
          
          genai.configure(api_key=api_key)
          # Using Gemini 2.5 Flash - fastest model
          model = genai.GenerativeModel('gemini-2.5-flash')
          
          # Read logs
          with open("/tmp/workflow_logs.txt", "r") as f:
              logs = f.read()
          
          # Limit to last 3000 chars to avoid token limits
          logs = logs[-3000:]
          
          prompt = f"""You are an expert DevOps engineer and software developer.
          
          A GitHub Actions workflow failed. Analyze the error and provide a detailed technical task.
          
          Workflow Name: ${{ steps.workflow.outputs.workflow_name }}
          Branch: ${{ steps.workflow.outputs.head_branch }}
          Run #${{ steps.workflow.outputs.run_number }}
          
          Error Logs:
          ```
          {logs}
          ```
          
          Provide analysis in this JSON format:
          {{
            "problem": "Brief description of what failed",
            "root_cause": "Why it happened",
            "severity": "critical|high|medium|low",
            "solution_steps": ["step 1", "step 2", ...],
            "code_fix": "Python/YAML code to fix (if applicable) or empty string if no fix needed",
            "file_to_modify": "path/to/file or null if no single file fix",
            "suggested_commit_message": "git commit message",
            "technical_task": "Detailed technical task for fixing",
            "auto_fix_possible": true/false
          }}
          
          Be precise and actionable."""
          
          response = model.generate_content(prompt)
          
          try:
              analysis = json.loads(response.text)
          except:
              # Extract JSON from response
              import re
              match = re.search(r'\{.*\}', response.text, re.DOTALL)
              if match:
                  analysis = json.loads(match.group())
              else:
                  analysis = {
                      "problem": "Failed to parse error",
                      "root_cause": response.text[:200],
                      "severity": "high",
                      "solution_steps": [],
                      "auto_fix_possible": False,
                      "code_fix": ""
                  }
          
          # Save analysis
          with open("/tmp/analysis.json", "w") as f:
              json.dump(analysis, f, indent=2)
          
          # Output for next step
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"problem={analysis.get('problem', 'Unknown')[:100]}\n")
              f.write(f"severity={analysis.get('severity', 'medium')}\n")
              f.write(f"auto_fix_possible={str(analysis.get('auto_fix_possible', False)).lower()}\n")
          
          print(json.dumps(analysis, indent=2))
          
          PYTHON_SCRIPT
      
      - name: Create or Update GitHub Issue
        if: always()
        id: issue
        run: |
          python3 << 'PYTHON_SCRIPT'
          import json
          import subprocess
          import os
          from datetime import datetime
          
          with open("/tmp/analysis.json", "r") as f:
              analysis = json.load(f)
          
          issue_title = f"ðŸ”´ [{analysis.get('severity', 'medium').upper()}] {analysis.get('problem', 'Unknown')[:80]}"
          
          issue_body = f"""## ðŸš¨ Failure Analysis
          
          **Workflow:** ${{ steps.workflow.outputs.workflow_name }}
          **Run:** [${{ steps.workflow.outputs.run_number }}](https://github.com/${{ github.repository }}/actions/runs/${{ steps.workflow.outputs.workflow_id }})
          **Branch:** `${{ steps.workflow.outputs.head_branch }}`
          **Commit:** `${{ steps.workflow.outputs.head_sha }}`
          
          ### Problem
          {analysis.get('problem', 'N/A')}
          
          ### Root Cause
          {analysis.get('root_cause', 'N/A')}
          
          ### Severity
          **{analysis.get('severity', 'medium').upper()}**
          
          ### Solution Steps
          {chr(10).join(f'- {step}' for step in analysis.get('solution_steps', []))}
          
          ### Technical Task
          {analysis.get('technical_task', 'N/A')}
          
          ### Suggested Code Fix
          ```python
          {analysis.get('code_fix', 'N/A')}
          ```
          
          ### Auto-Fix Status
          - Auto-fix possible: `{analysis.get('auto_fix_possible', False)}`
          - Status: Creating PR with suggested changes
          
          ---
          *Generated by Auto-Fix Agent ðŸ¤– at {datetime.now().isoformat()}*
          """
          
          # Create issue with gh CLI
          result = subprocess.run(
              [
                  "gh", "issue", "create",
                  "--title", issue_title,
                  "--body", issue_body,
                  "--label", "bug,auto-generated"
              ],
              capture_output=True,
              text=True,
              env={**os.environ, "GH_TOKEN": "${{ github.token }}"}
          )
          
          if result.returncode == 0:
              issue_url = result.stdout.strip()
              print(f"âœ… Created issue: {issue_url}")
              with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                  f.write(f"issue_url={issue_url}\n")
          else:
              print(f"âš ï¸ Failed to create issue: {result.stderr}")
          
          PYTHON_SCRIPT
      
      - name: Create PR with Auto-Fix
        if: ${{ steps.gemini.outputs.auto_fix_possible == 'true' }}
        id: pr
        run: |
          python3 << 'PYTHON_SCRIPT'
          import json
          import os
          import subprocess
          import datetime
          
          # Load analysis
          with open("/tmp/analysis.json", "r") as f:
              analysis = json.load(f)
          
          file_to_modify = analysis.get('file_to_modify')
          code_fix = analysis.get('code_fix', '').strip()
          commit_msg = analysis.get('suggested_commit_message')
          
          if not file_to_modify or not code_fix:
              print("âš ï¸ No code fix to apply")
              exit(0)
          
          print(f"ðŸ”§ Creating PR with auto-fix...")
          print(f"ðŸ“„ File: {file_to_modify}")
          print(f"ðŸ’¾ Applying code fix...")
          
          # Create new branch
          timestamp = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
          branch_name = f"auto-fix/run-${{ steps.workflow.outputs.run_number }}-{timestamp}"
          
          subprocess.run(["git", "config", "user.email", "auto-fix-agent@github.com"])
          subprocess.run(["git", "config", "user.name", "Auto-Fix Agent"])
          
          # Create and checkout new branch from main
          subprocess.run(["git", "checkout", "-b", branch_name, "origin/main"])
          
          # Apply fix
          if os.path.exists(file_to_modify):
              with open(file_to_modify, "w") as f:
                  f.write(code_fix)
              
              # Commit
              subprocess.run(["git", "add", file_to_modify])
              result = subprocess.run(
                  ["git", "commit", "-m", f"{commit_msg}\n\n[auto-fix-agent run #${{ steps.workflow.outputs.run_number }}]\nWorkflow: ${{ steps.workflow.outputs.workflow_name }}"],
                  capture_output=True,
                  text=True
              )
              
              if result.returncode == 0:
                  # Push branch
                  result = subprocess.run(["git", "push", "-u", "origin", branch_name], capture_output=True, text=True)
                  
                  if result.returncode == 0:
                      print(f"âœ… Pushed branch: {branch_name}")
                      
                      # Create PR
                      pr_title = f"ðŸ”§ Auto-Fix: {analysis.get('problem', 'Unknown')[:60]}"
                      pr_body = f"""## Auto-Fix PR
                      
                      **Issue:** {analysis.get('problem', 'N/A')}
                      **Root Cause:** {analysis.get('root_cause', 'N/A')}
                      **Severity:** {analysis.get('severity', 'medium')}
                      
                      ### Solution
                      {chr(10).join(f'- {step}' for step in analysis.get('solution_steps', []))}
                      
                      ### Changed Files
                      - `{file_to_modify}`
                      
                      ### Workflow Run
                      [${{ steps.workflow.outputs.workflow_name }} #${{ steps.workflow.outputs.run_number }}](https://github.com/${{ github.repository }}/actions/runs/${{ steps.workflow.outputs.workflow_id }})
                      
                      ---
                      *Created by Auto-Fix Agent ðŸ¤–*
                      *Please review and merge manually*
                      """
                      
                      result = subprocess.run(
                          [
                              "gh", "pr", "create",
                              "--base", "main",
                              "--head", branch_name,
                              "--title", pr_title,
                              "--body", pr_body,
                              "--label", "auto-generated,auto-fix"
                          ],
                          capture_output=True,
                          text=True,
                          env={**os.environ, "GH_TOKEN": "${{ github.token }}"}
                      )
                      
                      if result.returncode == 0:
                          pr_url = result.stdout.strip()
                          print(f"âœ… Created PR: {pr_url}")
                          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                              f.write(f"pr_url={pr_url}\n")
                      else:
                          print(f"âŒ PR creation failed: {result.stderr}")
                  else:
                      print(f"âŒ Push failed: {result.stderr}")
              else:
                  print(f"âš ï¸ Commit failed: {result.stderr}")
          else:
              print(f"âŒ File not found: {file_to_modify}")
          
          PYTHON_SCRIPT
      
      - name: Summary
        if: always()
        run: |
          echo "## ðŸ¤– Auto-Fix Agent Summary"
          echo ""
          echo "**Status:** ${{ job.status }}"
          echo "**Workflow:** ${{ steps.workflow.outputs.workflow_name }}"
          echo "**Severity:** ${{ steps.gemini.outputs.severity }}"
          echo "**Auto-fix possible:** ${{ steps.gemini.outputs.auto_fix_possible }}"
          echo ""
          if [ "${{ steps.issue.outputs.issue_url }}" != "" ]; then
            echo "**Issue:** ${{ steps.issue.outputs.issue_url }}"
          fi
          if [ "${{ steps.pr.outputs.pr_url }}" != "" ]; then
            echo "**PR:** ${{ steps.pr.outputs.pr_url }}"
          fi
          echo ""
          echo "**Mode:** Always enabled (creates PR, manual merge required)"
