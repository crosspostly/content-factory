name: Auto-Fix Agent

on:
  workflow_run:
    workflows: ["Generate Content (Part 1 MVP)", "test"]
    types: [completed]
  workflow_dispatch:
    inputs:
      auto_commit:
        description: 'Auto-commit fixes to repo'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

jobs:
  analyze-failure:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}
    permissions:
      contents: read
      actions: read
      issues: write
      pull-requests: write
    
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
      
      - name: Download workflow logs
        uses: actions/download-artifact@v4
        with:
          path: workflow-logs
          github-token: ${{ github.token }}
        continue-on-error: true
      
      - name: Get workflow run details
        id: workflow
        run: |
          echo "workflow_name=${{ github.event.workflow_run.name }}" >> $GITHUB_OUTPUT
          echo "workflow_id=${{ github.event.workflow_run.id }}" >> $GITHUB_OUTPUT
          echo "run_number=${{ github.event.workflow_run.run_number }}" >> $GITHUB_OUTPUT
          echo "head_branch=${{ github.event.workflow_run.head_branch }}" >> $GITHUB_OUTPUT
          echo "head_sha=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_OUTPUT
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          pip install google-generativeai requests
      
      - name: Fetch GitHub Actions logs
        id: logs
        run: |
          python3 << 'PYTHON_SCRIPT'
          import subprocess
          import os
          import json
          
          # Get workflow run logs
          workflow_id = "${{ steps.workflow.outputs.workflow_id }}"
          
          # Use gh CLI to get logs
          result = subprocess.run(
              ["gh", "run", "view", workflow_id, "--log"],
              capture_output=True,
              text=True,
              env={**os.environ, "GH_TOKEN": "${{ github.token }}"}
          )
          
          logs = result.stdout + result.stderr
          
          # Save to file
          with open("/tmp/workflow_logs.txt", "w") as f:
              f.write(logs)
          
          # Extract error section
          lines = logs.split("\n")
          error_lines = []
          capture = False
          for line in lines:
              if "error" in line.lower() or "failed" in line.lower() or capture:
                  error_lines.append(line)
                  capture = True
              if capture and len(error_lines) > 100:
                  break
          
          error_summary = "\n".join(error_lines[-50:])
          
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"error_summary<<EOF\n{error_summary}\nEOF\n")
          
          PYTHON_SCRIPT
      
      - name: Analyze with Gemini
        id: gemini
        run: |
          python3 << 'PYTHON_SCRIPT'
          import google.generativeai as genai
          import os
          import json
          
          api_key = "${{ secrets.GOOGLE_AI_API_KEY }}"
          if not api_key:
              print("ERROR: GOOGLE_AI_API_KEY not set")
              exit(1)
          
          genai.configure(api_key=api_key)
          model = genai.GenerativeModel('gemini-2.5-flash')
          
          # Read logs
          with open("/tmp/workflow_logs.txt", "r") as f:
              logs = f.read()
          
          # Limit to last 3000 chars
          logs = logs[-3000:]
          
          prompt = f"""You are an expert DevOps engineer and software developer.
          
A GitHub Actions workflow failed. Analyze the error and provide a detailed technical task.

Workflow Name: ${{ steps.workflow.outputs.workflow_name }}
Branch: ${{ steps.workflow.outputs.head_branch }}
Run #${{ steps.workflow.outputs.run_number }}

Error Logs:
```
{logs}
```

Provide analysis in this JSON format:
{{
  "problem": "Brief description of what failed",
  "root_cause": "Why it happened",
  "severity": "critical|high|medium|low",
  "solution_steps": ["step 1", "step 2", ...],
  "code_fix": "Python/YAML code to fix (if applicable)",
  "file_to_modify": "path/to/file or null",
  "suggested_commit_message": "git commit message",
  "technical_task": "Detailed technical task for fixing",
  "auto_fix_possible": true/false
}}

Be precise and actionable."""
          
          response = model.generate_content(prompt)
          
          try:
              analysis = json.loads(response.text)
          except:
              # Extract JSON from response
              import re
              match = re.search(r'\{.*\}', response.text, re.DOTALL)
              if match:
                  analysis = json.loads(match.group())
              else:
                  analysis = {
                      "problem": "Failed to parse error",
                      "root_cause": response.text,
                      "severity": "high",
                      "solution_steps": [],
                      "auto_fix_possible": False
                  }
          
          # Save analysis
          with open("/tmp/analysis.json", "w") as f:
              json.dump(analysis, f, indent=2)
          
          # Output for next step
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"problem={analysis.get('problem', 'Unknown')}\n")
              f.write(f"severity={analysis.get('severity', 'medium')}\n")
              f.write(f"auto_fix_possible={str(analysis.get('auto_fix_possible', False)).lower()}\n")
          
          print(json.dumps(analysis, indent=2))
          
          PYTHON_SCRIPT
      
      - name: Create GitHub Issue
        if: always()
        id: issue
        run: |
          python3 << 'PYTHON_SCRIPT'
          import json
          import subprocess
          import os
          
          with open("/tmp/analysis.json", "r") as f:
              analysis = json.load(f)
          
          issue_title = f"ðŸ”´ [{analysis.get('severity', 'medium').upper()}] Workflow Failed: {analysis.get('problem', 'Unknown')}"
          
          issue_body = f"""## ðŸš¨ Failure Analysis

**Workflow:** ${{ steps.workflow.outputs.workflow_name }}
**Run:** [${{ steps.workflow.outputs.run_number }}](https://github.com/${{ github.repository }}/actions/runs/${{ steps.workflow.outputs.workflow_id }})
**Branch:** `${{ steps.workflow.outputs.head_branch }}`
**Commit:** `${{ steps.workflow.outputs.head_sha }}`

### Problem
{analysis.get('problem', 'N/A')}

### Root Cause
{analysis.get('root_cause', 'N/A')}

### Severity
**{analysis.get('severity', 'medium').upper()}**

### Solution Steps
```
{chr(10).join(f'- {step}' for step in analysis.get('solution_steps', []))}
```

### Technical Task
{analysis.get('technical_task', 'N/A')}

### Code Fix
```python
{analysis.get('code_fix', 'N/A')}
```

### Auto-Fix Status
- Auto-fix possible: `{analysis.get('auto_fix_possible', False)}`
- Auto-fix enabled: `${{ github.event.inputs.auto_commit || 'false' }}`

---
*Generated by Auto-Fix Agent ðŸ¤–*
"""
          
          # Create issue with gh CLI
          result = subprocess.run(
              [
                  "gh", "issue", "create",
                  "--title", issue_title,
                  "--body", issue_body,
                  "--label", "bug,auto-generated"
              ],
              capture_output=True,
              text=True,
              env={**os.environ, "GH_TOKEN": "${{ github.token }}"}
          )
          
          if result.returncode == 0:
              issue_url = result.stdout.strip()
              print(f"âœ… Created issue: {issue_url}")
              with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                  f.write(f"issue_url={issue_url}\n")
          else:
              print(f"âš ï¸ Failed to create issue: {result.stderr}")
          
          PYTHON_SCRIPT
      
      - name: Auto-Fix with Gemini
        if: ${{ steps.gemini.outputs.auto_fix_possible == 'true' && (github.event.inputs.auto_commit == 'true' || github.event_name == 'workflow_run') }}
        id: fix
        run: |
          python3 << 'PYTHON_SCRIPT'
          import json
          import os
          import subprocess
          
          # Load analysis
          with open("/tmp/analysis.json", "r") as f:
              analysis = json.load(f)
          
          file_to_modify = analysis.get('file_to_modify')
          code_fix = analysis.get('code_fix')
          commit_msg = analysis.get('suggested_commit_message')
          
          if not file_to_modify or not code_fix:
              print("âŒ Cannot apply auto-fix: missing file or code")
              exit(1)
          
          print(f"ðŸ”§ Attempting auto-fix...")
          print(f"ðŸ“„ File: {file_to_modify}")
          print(f"ðŸ’¾ Code:\n{code_fix}")
          
          # Check if auto_commit is enabled in config
          auto_commit_mode = None
          try:
              with open(".github/auto-fix-config.yml", "r") as f:
                  import yaml
                  config = yaml.safe_load(f)
                  auto_commit_mode = config.get('auto_fix', {}).get('auto_commit', False)
          except:
              # Default: don't auto-commit unless explicitly enabled
              auto_commit_mode = False
          
          if auto_commit_mode:
              print("âœ… Auto-commit is ENABLED")
              # Apply fix
              if os.path.exists(file_to_modify):
                  with open(file_to_modify, "w") as f:
                      f.write(code_fix)
                  
                  # Git commit
                  subprocess.run(["git", "config", "user.email", "auto-fix-agent@github.com"])
                  subprocess.run(["git", "config", "user.name", "Auto-Fix Agent"])
                  subprocess.run(["git", "add", file_to_modify])
                  subprocess.run(["git", "commit", "-m", f"{commit_msg}\n\n[auto-fix-agent]"])
                  result = subprocess.run(["git", "push"], capture_output=True, text=True)
                  
                  if result.returncode == 0:
                      print(f"âœ… Fixed and committed: {commit_msg}")
                      with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                          f.write(f"fix_applied=true\n")
                  else:
                      print(f"âš ï¸ Push failed: {result.stderr}")
              else:
                  print(f"âŒ File not found: {file_to_modify}")
          else:
              print("âš ï¸ Auto-commit is DISABLED")
              print("ðŸ’¡ To enable: set 'auto_commit: true' in .github/auto-fix-config.yml")
          
          PYTHON_SCRIPT
      
      - name: Summary
        if: always()
        run: |
          echo "## ðŸ¤– Auto-Fix Agent Summary"
          echo ""
          echo "**Status:** ${{ job.status }}"
          echo "**Workflow:** ${{ steps.workflow.outputs.workflow_name }}"
          echo "**Severity:** ${{ steps.gemini.outputs.severity }}"
          echo "**Auto-fix possible:** ${{ steps.gemini.outputs.auto_fix_possible }}"
          echo "**Auto-commit mode:** ${{ github.event.inputs.auto_commit || 'default (from config)' }}"
          echo ""
          if [ "${{ steps.issue.outputs.issue_url }}" != "" ]; then
            echo "**Issue:** ${{ steps.issue.outputs.issue_url }}"
          fi
          echo ""
          echo "**Analysis saved to:** `/tmp/analysis.json`"
