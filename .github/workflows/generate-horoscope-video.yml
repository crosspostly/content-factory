name: Generate Horoscope Video

on:
  # –†—É—á–Ω–æ–π –∑–∞–ø—É—Å–∫ —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
  workflow_dispatch:
    inputs:
      format:
        description: 'Video format'
        required: true
        default: 'shorts'
        type: choice
        options:
          - shorts
          - long-form
          - ad
      date:
        description: 'Horoscope date (YYYY-MM-DD, optional)'
        required: false
        type: string
      project:
        description: 'Project name'
        required: false
        default: 'youtube_horoscope'
        type: string
      publish:
        description: 'Publish after generation'
        required: false
        default: false
        type: boolean
  
  # –ü–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—é: –∫–∞–∂–¥—ã–π –¥–µ–Ω—å –≤ 06:00 UTC (09:00 MSK)
  schedule:
    - cron: '0 6 * * *'

jobs:
  generate-video:
    runs-on: ubuntu-22.04
    timeout-minutes: 60
    
    env:
      GOOGLE_AI_API_KEY: ${{ secrets.GOOGLE_AI_API_KEY }}
      PIXABAY_API_KEY: ${{ secrets.PIXABAY_API_KEY }}
      PROJECT: ${{ github.event.inputs.project || 'youtube_horoscope' }}
      FORMAT: ${{ github.event.inputs.format || 'shorts' }}
      HOROSCOPE_DATE: ${{ github.event.inputs.date }}
      PUBLISH: ${{ github.event.inputs.publish || false }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
      
      - name: Setup Python 3.11
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Cache system dependencies
        uses: awalsh128/cache-apt-pkgs-action@latest
        with:
          packages: ffmpeg imagemagick ghostscript fonts-dejavu-core libsm6 libxext6
          version: 1.0
      
      - name: Install system dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y ffmpeg imagemagick ghostscript fonts-dejavu-core libsm6 libxext6
          echo "‚úÖ FFmpeg version:"
          ffmpeg -version | head -1
          echo "‚úÖ Python version:"
          python --version
      
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      
      - name: Validate project config
        run: |
          python3 << 'PYTHON'
          import json
          from pathlib import Path
          from core.utils.config_loader import load_project_config
          
          project = "${{ env.PROJECT }}"
          print(f"\nüìã Validating project: {project}")
          
          try:
              config = load_project_config(project)
              print(f"‚úÖ Project config loaded successfully")
              print(f"   - Name: {config.project.name}")
              print(f"   - Language: {config.project.language}")
              print(f"   - Niche: {config.project.niche}")
          except Exception as e:
              print(f"‚ùå Failed to load config: {e}")
              exit(1)
          PYTHON
      
      - name: Generate Script (Part 1)
        id: script_generation
        env:
          HOROSCOPE_DATE: ${{ env.HOROSCOPE_DATE }}
        run: |
          python3 << 'PYTHON'
          import json
          import sys
          from datetime import datetime
          from pathlib import Path
          from core.generators.script_generator import ScriptGenerator
          from core.utils.config_loader import load_project_config
          
          project = "${{ env.PROJECT }}"
          format = "${{ env.FORMAT }}"
          date_input = "${{ env.HOROSCOPE_DATE }}"
          
          print(f"\nüé¨ Part 1: Script Generation")
          print(f"   Project: {project}")
          print(f"   Format: {format}")
          
          try:
              config = load_project_config(project)
              generator = ScriptGenerator(config)
              
              # –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –¥–∞—Ç—É
              if date_input:
                  try:
                      horoscope_date = datetime.strptime(date_input, '%Y-%m-%d').date()
                  except ValueError:
                      print(f"‚ùå Invalid date format: {date_input}. Using today.")
                      horoscope_date = datetime.now().date()
              else:
                  horoscope_date = datetime.now().date()
              
              print(f"   Date: {horoscope_date}")
              
              # –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–º–ø—Ç
              prompt_file = config.generation.prompt_files[f"{format}_script"]
              print(f"   Prompt: {prompt_file}")
              
              # –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Å—Ü–µ–Ω–∞—Ä–∏–π
              script_result = generator.generate_script(
                  format=format,
                  horoscope_date=str(horoscope_date),
                  model="gemini"  # –∏–ª–∏ "qwen" –¥–ª—è fallback
              )
              
              script_path = script_result['script_path']
              print(f"‚úÖ Script generated: {script_path}")
              
              # –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ output –¥–ª—è —Å–ª–µ–¥—É—é—â–∏—Ö —à–∞–≥–æ–≤
              output_dir = Path(f"output/scripts/{project}")
              output_dir.mkdir(parents=True, exist_ok=True)
              
              # GitHub Actions output
              with open(Path(script_path)) as f:
                  script_data = json.load(f)
              
              print(f"\nüìä Script details:")
              print(f"   ID: {script_data.get('id')}")
              print(f"   Duration: {script_data.get('total_duration_sec', 0)}s")
              print(f"   Blocks: {len(script_data.get('blocks', []))}")
              
              # –í—ã–≤–æ–¥ –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —à–∞–≥–∞
              with open(Path.cwd() / f".script_path_{format}", 'w') as f:
                  f.write(str(script_path))
              
              sys.exit(0)
          
          except Exception as e:
              import traceback
              print(f"\n‚ùå Script generation failed:")
              print(traceback.format_exc())
              sys.exit(1)
          PYTHON
      
      - name: Synthesize Audio (Part 2)
        id: audio_generation
        run: |
          python3 << 'PYTHON'
          import json
          import sys
          from pathlib import Path
          from core.generators.tts_generator import TTSGenerator
          from core.utils.config_loader import load_project_config
          
          project = "${{ env.PROJECT }}"
          format = "${{ env.FORMAT }}"
          
          print(f"\nüéôÔ∏è  Part 2: Audio Synthesis (TTS)")
          print(f"   Format: {format}")
          
          try:
              config = load_project_config(project)
              tts = TTSGenerator(config)
              
              # –ü–æ–ª—É—á–∏—Ç—å –ø—É—Ç—å –∫ —Å—Ü–µ–Ω–∞—Ä–∏—é
              script_path_file = Path.cwd() / f".script_path_{format}"
              if not script_path_file.exists():
                  print(f"‚ùå Script path file not found: {script_path_file}")
                  sys.exit(1)
              
              script_path = Path(script_path_file.read_text().strip())
              print(f"   Script: {script_path}")
              
              # –ó–∞–≥—Ä—É–∑–∏—Ç—å —Å—Ü–µ–Ω–∞—Ä–∏–π
              with open(script_path) as f:
                  script_data = json.load(f)
              
              # –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∞—É–¥–∏–æ –¥–ª—è –±–ª–æ–∫–æ–≤
              audio_result = tts.synthesize_blocks(
                  blocks=script_data.get('blocks', []),
                  output_dir=f"output/audio/{project}",
                  format=format
              )
              
              audio_path = audio_result['merged_audio_path']
              print(f"‚úÖ Audio synthesized: {audio_path}")
              print(f"   Duration: {audio_result.get('total_duration_sec', 0)}s")
              print(f"   Sample rate: {audio_result.get('sample_rate', 22050)} Hz")
              
              # –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—É—Ç—å –¥–ª—è –≤–∏–¥–µ–æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
              with open(Path.cwd() / f".audio_path_{format}", 'w') as f:
                  f.write(str(audio_path))
              
              sys.exit(0)
          
          except Exception as e:
              import traceback
              print(f"\n‚ùå Audio synthesis failed:")
              print(traceback.format_exc())
              sys.exit(1)
          PYTHON
      
      - name: Render Video (Part 3)
        id: video_rendering
        run: |
          python3 << 'PYTHON'
          import json
          import sys
          from pathlib import Path
          from core.generators.video_renderer import VideoRenderer
          from core.utils.config_loader import load_project_config
          
          project = "${{ env.PROJECT }}"
          format = "${{ env.FORMAT }}"
          
          print(f"\nüé• Part 3: Video Rendering")
          print(f"   Format: {format}")
          
          try:
              config = load_project_config(project)
              renderer = VideoRenderer(config)
              
              # –ü–æ–ª—É—á–∏—Ç—å –ø—É—Ç–∏ –∫ —Å—Ü–µ–Ω–∞—Ä–∏—é –∏ –∞—É–¥–∏–æ
              script_path_file = Path.cwd() / f".script_path_{format}"
              audio_path_file = Path.cwd() / f".audio_path_{format}"
              
              if not script_path_file.exists() or not audio_path_file.exists():
                  print(f"‚ùå Missing script or audio path files")
                  sys.exit(1)
              
              script_path = Path(script_path_file.read_text().strip())
              audio_path = Path(audio_path_file.read_text().strip())
              
              print(f"   Script: {script_path}")
              print(f"   Audio: {audio_path}")
              
              # –ó–∞–≥—Ä—É–∑–∏—Ç—å —Å—Ü–µ–Ω–∞—Ä–∏–π
              with open(script_path) as f:
                  script_data = json.load(f)
              
              # –í—ã–±—Ä–∞—Ç—å –º–µ—Ç–æ–¥ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞
              output_dir = Path(f"output/videos/{project}")
              output_dir.mkdir(parents=True, exist_ok=True)
              
              output_file = output_dir / f"{format}_{script_data.get('id', 'video')}.mp4"
              
              # –†–µ–Ω–¥–µ—Ä–∏—Ç—å –≤–∏–¥–µ–æ
              if format == "shorts":
                  render_method = renderer.render_shorts
              elif format == "long-form":
                  render_method = renderer.render_long_form
              elif format == "ad":
                  render_method = renderer.render_ad
              else:
                  print(f"‚ùå Unknown format: {format}")
                  sys.exit(1)
              
              print(f"\n‚è≥ Rendering {format} video...")
              video_result = render_method(
                  audio_path=str(audio_path),
                  script_data=script_data,
                  output_path=str(output_file)
              )
              
              video_path = video_result['video_path']
              print(f"\n‚úÖ Video rendered: {video_path}")
              print(f"   Resolution: {video_result.get('resolution')}")
              print(f"   Duration: {video_result.get('duration_sec')}s")
              print(f"   File size: {video_result.get('file_size_mb', 0):.1f} MB")
              print(f"   FPS: {video_result.get('fps')}")
              print(f"   Codec: {video_result.get('codec')}")
              
              # –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –¥–ª—è –ø—É–±–ª–∏–∫–∞—Ü–∏–∏
              metadata = {
                  "video_path": str(video_path),
                  "format": format,
                  "project": project,
                  "script_data": script_data,
                  "video_result": video_result
              }
              
              metadata_file = output_dir / f".metadata_{script_data.get('id')}.json"
              with open(metadata_file, 'w') as f:
                  json.dump(metadata, f, indent=2, ensure_ascii=False)
              
              sys.exit(0)
          
          except Exception as e:
              import traceback
              print(f"\n‚ùå Video rendering failed:")
              print(traceback.format_exc())
              sys.exit(1)
          PYTHON
      
      - name: Generate Metadata
        id: metadata
        run: |
          python3 << 'PYTHON'
          import json
          from pathlib import Path
          from core.utils.config_loader import load_project_config
          
          project = "${{ env.PROJECT }}"
          format = "${{ env.FORMAT }}"
          
          print(f"\nüìù Generating metadata")
          
          try:
              config = load_project_config(project)
              output_dir = Path(f"output/videos/{project}")
              
              # –ù–∞–π—Ç–∏ –≤–∏–¥–µ–æ —Ñ–∞–π–ª
              video_files = list(output_dir.glob(f"{format}_*.mp4"))
              if not video_files:
                  print(f"‚ö†Ô∏è  No video files found")
                  sys.exit(0)
              
              video_path = video_files[-1]  # –°–∞–º—ã–π –Ω–æ–≤—ã–π
              
              # –°–æ–∑–¥–∞—Ç—å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –¥–ª—è YouTube
              metadata = {
                  "title": f"–ì–æ—Ä–æ—Å–∫–æ–ø –Ω–∞ {datetime.now().strftime('%d.%m.%Y')}",
                  "description": f"–í–∞—à –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –≥–æ—Ä–æ—Å–∫–æ–ø –Ω–∞ {datetime.now().strftime('%d.%m.%Y')}\n\n–ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –∫–∞–Ω–∞–ª –¥–ª—è –Ω–æ–≤—ã—Ö –≥–æ—Ä–æ—Å–∫–æ–ø–æ–≤ –∫–∞–∂–¥—ã–π –¥–µ–Ω—å!",
                  "tags": ["–≥–æ—Ä–æ—Å–∫–æ–ø", "–∞—Å—Ç—Ä–æ–ª–æ–≥–∏—è", "–∑–æ–¥–∏–∞–∫"],
                  "category": "Entertainment",
                  "visibility": "public"
              }
              
              metadata_file = output_dir / f"metadata_{format}.json"
              with open(metadata_file, 'w') as f:
                  json.dump(metadata, f, indent=2, ensure_ascii=False)
              
              print(f"‚úÖ Metadata generated: {metadata_file}")
              print(f"   Title: {metadata['title']}")
              
          except Exception as e:
              print(f"‚ö†Ô∏è  Metadata generation skipped: {e}")
          PYTHON
      
      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: horoscope-video-${{ github.run_number }}
          path: |
            output/scripts/
            output/audio/
            output/videos/
          retention-days: 7
      
      - name: Post generation summary
        if: success()
        run: |
          python3 << 'PYTHON'
          from pathlib import Path
          
          project = "${{ env.PROJECT }}"
          format = "${{ env.FORMAT }}"
          
          video_dir = Path(f"output/videos/{project}")
          video_files = list(video_dir.glob(f"{format}_*.mp4"))
          
          if video_files:
              video_path = video_files[-1]
              print(f"\n" + "="*60)
              print(f"‚úÖ HOROSCOPE VIDEO GENERATION COMPLETED")
              print(f"="*60)
              print(f"\nProject: {project}")
              print(f"Format: {format}")
              print(f"Video: {video_path}")
              print(f"Size: {video_path.stat().st_size / (1024*1024):.1f} MB")
              print(f"\nüì¶ Artifacts uploaded to GitHub Actions")
              print(f"‚è≠Ô∏è  Next: Download and review, or publish to YouTube")
              print(f"\n" + "="*60)
          PYTHON
      
      - name: Publish to YouTube
        if: ${{ github.event.inputs.publish == 'true' && success() }}
        run: |
          echo "üöÄ Publishing to YouTube..."
          echo "Note: Full YouTube integration in Part 4"
          echo "For now, download the video from artifacts and publish manually"

  notify:
    runs-on: ubuntu-22.04
    needs: generate-video
    if: always()
    
    steps:
      - name: Send Telegram notification
        if: ${{ secrets.TELEGRAM_BOT_TOKEN && secrets.TELEGRAM_CHAT_ID }}
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          STATUS="${{ needs.generate-video.result }}"
          EMOJI="‚úÖ"
          
          if [ "$STATUS" != "success" ]; then
            EMOJI="‚ùå"
          fi
          
          MESSAGE="$EMOJI Horoscope Video Generation: $STATUS\n"
          MESSAGE="${MESSAGE}Format: ${{ github.event.inputs.format || 'shorts' }}\n"
          MESSAGE="${MESSAGE}Workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          curl -s -X POST \
            -H 'Content-Type: application/json' \
            -d "{ \"chat_id\": \"$TELEGRAM_CHAT_ID\", \"text\": \"$MESSAGE\", \"parse_mode\": \"HTML\" }" \
            "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage"
