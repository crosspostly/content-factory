name: Generate Horoscope Video

# –ó–∞–ø—É—Å–∫: –≤—Ä—É—á–Ω—É—é —á–µ—Ä–µ–∑ Actions –∏–ª–∏ –ø–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—é
on:
  workflow_dispatch:
    inputs:
      format:
        description: 'Video format (shorts | long-form | ad)'
        required: true
        default: 'shorts'
        type: choice
        options:
          - shorts
          - long-form
          - ad
      date:
        description: 'Horoscope date (YYYY-MM-DD, optional - uses today)'
        required: false
        type: string
      project:
        description: 'Project name'
        required: false
        default: 'youtube_horoscope'
        type: string
  
  # –ü–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—é: –∫–∞–∂–¥—ã–π –¥–µ–Ω—å –≤ 06:00 UTC (09:00 MSK) –¥–ª—è shorts
  schedule:
    - cron: '0 6 * * *'

jobs:
  generate-video:
    runs-on: ubuntu-22.04
    timeout-minutes: 45
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
      
      - name: Setup Python 3.11
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Cache system dependencies
        uses: awalsh128/cache-apt-pkgs-action@latest
        with:
          packages: ffmpeg imagemagick ghostscript fonts-dejavu-core libsm6 libxext6
          version: 1.0
      
      - name: Install system dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y ffmpeg imagemagick ghostscript fonts-dejavu-core libsm6 libxext6
          echo "‚úÖ FFmpeg: $(ffmpeg -version | head -1)"
          echo "‚úÖ Python: $(python --version)"
      
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt -q
      
      - name: Determine format and date
        id: params
        env:
          INPUT_FORMAT: ${{ github.event.inputs.format }}
          INPUT_DATE: ${{ github.event.inputs.date }}
          INPUT_PROJECT: ${{ github.event.inputs.project }}
        run: |
          python3 << 'EOF'
          import os
          from datetime import date
          
          # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã
          fmt = os.getenv('INPUT_FORMAT') or 'shorts'
          dt = os.getenv('INPUT_DATE') or date.today().isoformat()
          proj = os.getenv('INPUT_PROJECT') or 'youtube_horoscope'
          
          print(f"Format: {fmt}")
          print(f"Date: {dt}")
          print(f"Project: {proj}")
          
          # –ó–∞–ø–∏—Å—å –¥–ª—è —Å–ª–µ–¥—É—é—â–∏—Ö —à–∞–≥–æ–≤
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"format={fmt}\n")
              f.write(f"date={dt}\n")
              f.write(f"project={proj}\n")
          EOF
      
      - name: Generate Content (Part 1 ‚Üí Part 2 ‚Üí Part 3)
        id: generate
        env:
          GOOGLE_AI_API_KEY: ${{ secrets.GOOGLE_AI_API_KEY }}
          PIXABAY_API_KEY: ${{ secrets.PIXABAY_API_KEY }}
          FORMAT: ${{ steps.params.outputs.format }}
          DATE: ${{ steps.params.outputs.date }}
          PROJECT: ${{ steps.params.outputs.project }}
        run: |
          python3 << 'PYTHON_SCRIPT'
          import os
          import sys
          from pathlib import Path
          
          # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã
          project = os.getenv('PROJECT')
          fmt = os.getenv('FORMAT')
          target_date = os.getenv('DATE')
          
          print(f"\n" + "="*70)
          print(f"üé¨ HOROSCOPE VIDEO GENERATION PIPELINE")
          print(f"="*70)
          print(f"Project: {project}")
          print(f"Format: {fmt}")
          print(f"Date: {target_date}")
          print(f"\n")
          
          # –ó–∞–≥—Ä—É–∑–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥
          try:
              from core.utils.config_loader import load
              config = load(project)
              print(f"‚úÖ Config loaded: {project}")
          except Exception as e:
              print(f"‚ùå Failed to load config: {e}")
              sys.exit(1)
          
          # ========== PART 1: SCRIPT GENERATION ==========
          print(f"\nüìù PART 1: Script Generation")
          print(f"-" * 70)
          
          try:
              from core.generators import script_generator
              
              if fmt == "shorts":
                  script = script_generator.generate_short(config, target_date=target_date)
              elif fmt == "long_form":
                  script = script_generator.generate_long_form(config, target_date=target_date)
              elif fmt == "ad":
                  script = script_generator.generate_ad(config, product_id="horoscope_ad", target_date=target_date)
              else:
                  raise ValueError(f"Unknown format: {fmt}")
              
              script_path = script.get('_script_path')
              print(f"‚úÖ Script generated: {script_path}")
              print(f"   Format: {fmt}")
              print(f"   Date: {target_date}")
              
          except Exception as e:
              import traceback
              print(f"‚ùå Script generation failed:")
              print(traceback.format_exc())
              sys.exit(1)
          
          # ========== PART 2: TTS SYNTHESIS ==========
          print(f"\nüéôÔ∏è PART 2: TTS Synthesis (Gemini)")
          print(f"-" * 70)
          
          try:
              from core.generators import tts_generator
              
              api_key = os.getenv('GOOGLE_AI_API_KEY')
              if not api_key:
                  raise ValueError("GOOGLE_AI_API_KEY not set!")
              
              audio_map = tts_generator.synthesize(
                  config=config,
                  script=script,
                  mode=fmt,
                  api_key=api_key
              )
              
              print(f"‚úÖ Audio synthesized")
              print(f"   Engine: {audio_map.get('engine_used')}")
              print(f"   Duration: {audio_map.get('total_duration_sec'):.1f}s")
              print(f"   Sample rate: {audio_map.get('sample_rate')} Hz")
              print(f"   Blocks: {list(audio_map.get('blocks', {}).keys())}")
              
              for block_name, block_path in audio_map.get('blocks', {}).items():
                  if Path(block_path).exists():
                      size_mb = Path(block_path).stat().st_size / (1024*1024)
                      print(f"     - {block_name}: {block_path} ({size_mb:.1f}MB)")
          
          except Exception as e:
              import traceback
              print(f"‚ùå TTS synthesis failed:")
              print(traceback.format_exc())
              sys.exit(1)
          
          # ========== PART 3: VIDEO RENDERING ==========
          print(f"\nüé• PART 3: Video Rendering")
          print(f"-" * 70)
          
          try:
              from core.generators import video_renderer
              
              video_path = video_renderer.render(
                  config=config,
                  script=script,
                  audio_map=audio_map,
                  mode=fmt
              )
              
              # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –≤–∏–¥–µ–æ
              video_file = Path(video_path)
              if video_file.exists():
                  size_mb = video_file.stat().st_size / (1024*1024)
                  print(f"‚úÖ Video rendered: {video_path}")
                  print(f"   Size: {size_mb:.1f} MB")
              else:
                  raise FileNotFoundError(f"Video file not found: {video_path}")
          
          except Exception as e:
              import traceback
              print(f"‚ùå Video rendering failed:")
              print(traceback.format_exc())
              sys.exit(1)
          
          # ========== SUMMARY ==========
          print(f"\n" + "="*70)
          print(f"‚úÖ SUCCESS! Video generation complete")
          print(f"="*70)
          print(f"Project: {project}")
          print(f"Format: {fmt}")
          print(f"Output: {video_path}")
          print(f"Size: {size_mb:.1f} MB")
          print(f"\nVideo is ready for:")
          if fmt == "shorts":
              print(f"  - YouTube Shorts (1080√ó1920)")
              print(f"  - TikTok / Instagram Reels")
          elif fmt == "long_form":
              print(f"  - YouTube (1920√ó1080, horizontal)")
          elif fmt == "ad":
              print(f"  - Ad campaigns (1080√ó1920)")
          print(f"\nNext: Download from artifacts and publish to platforms")
          print(f"")
          
          PYTHON_SCRIPT
      
      - name: Generate metadata
        if: success()
        env:
          PROJECT: ${{ steps.params.outputs.project }}
          FORMAT: ${{ steps.params.outputs.format }}
          DATE: ${{ steps.params.outputs.date }}
        run: |
          python3 << 'PYTHON_META'
          import json
          import os
          from datetime import datetime
          from pathlib import Path
          
          project = os.getenv('PROJECT')
          fmt = os.getenv('FORMAT')
          target_date = os.getenv('DATE')
          
          output_dir = Path(f"output/videos/{project}")
          video_files = sorted(list(output_dir.glob(f"{fmt}.mp4"))) if output_dir.exists() else []
          
          if not video_files:
              print(f"‚ÑπÔ∏è No video files to generate metadata for")
              exit(0)
          
          video_path = video_files[-1]
          
          # –°–æ–∑–¥–∞—Ç—å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –¥–ª—è –ø–ª–∞—Ç—Ñ–æ—Ä–º
          metadata = {
              "title": f"–ì–æ—Ä–æ—Å–∫–æ–ø –Ω–∞ {target_date}",
              "description": f"–í–∞—à –ª–∏—á–Ω—ã–π –≥–æ—Ä–æ—Å–∫–æ–ø –Ω–∞ {target_date}\n\n–ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –∫–∞–Ω–∞–ª –¥–ª—è –Ω–æ–≤—ã—Ö –≥–æ—Ä–æ—Å–∫–æ–ø–æ–≤!",
              "tags": ["–≥–æ—Ä–æ—Å–∫–æ–ø", "–∞—Å—Ç—Ä–æ–ª–æ–≥–∏—è", "–∑–æ–¥–∏–∞–∫", "–∞—Å—Ç—Ä–æ"],
              "category": "Entertainment",
              "visibility": "public",
              "format": fmt,
              "date_generated": datetime.now().isoformat(),
              "video_path": str(video_path),
          }
          
          # –§–æ—Ä–º–∞—Ç-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
          if fmt == "shorts":
              metadata["platform"] = ["YouTube Shorts", "TikTok", "Instagram Reels"]
              metadata["recommended_tags"] = ["horoscope", "astrology", "zodiac", "viral"]
          elif fmt == "long_form":
              metadata["platform"] = ["YouTube"]
              metadata["chapters"] = [
                  {"title": "–õ—é–±–æ–≤—å", "timestamp": "0:10"},
                  {"title": "–î–µ–Ω—å–≥–∏", "timestamp": "4:00"},
                  {"title": "–ó–¥–æ—Ä–æ–≤—å–µ", "timestamp": "8:00"},
              ]
          elif fmt == "ad":
              metadata["platform"] = ["YouTube", "TikTok", "Instagram"]
              metadata["ad_duration_sec"] = 15
          
          metadata_path = output_dir / f"metadata_{fmt}.json"
          with open(metadata_path, 'w') as f:
              json.dump(metadata, f, indent=2, ensure_ascii=False)
          
          print(f"‚úÖ Metadata generated: {metadata_path}")
          PYTHON_META
      
      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: horoscope-output-${{ github.run_number }}
          path: |
            output/scripts/
            output/audio/
            output/videos/
          retention-days: 7
          if-no-files-found: warn
      
      - name: Summary
        if: success()
        env:
          FORMAT: ${{ steps.params.outputs.format }}
          PROJECT: ${{ steps.params.outputs.project }}
        run: |
          python3 << 'EOF'
          import os
          from pathlib import Path
          
          project = os.getenv('PROJECT')
          fmt = os.getenv('FORMAT')
          output_dir = Path(f"output/videos/{project}")
          
          video_files = sorted(list(output_dir.glob(f"{fmt}.mp4"))) if output_dir.exists() else []
          
          if video_files:
              video_path = video_files[-1]
              size_mb = video_path.stat().st_size / (1024*1024)
              print(f"\n" + "="*70)
              print(f"‚úÖ GENERATION COMPLETE")
              print(f"="*70)
              print(f"Video: {video_path.name}")
              print(f"Size: {size_mb:.1f} MB")
              print(f"\nüì• Download from GitHub Actions artifacts")
              print(f"üì§ Then publish to: YouTube, TikTok, Instagram")
              print(f"")
          else:
              print(f"‚ö†Ô∏è Video file not found")
          EOF

  notify-result:
    runs-on: ubuntu-22.04
    needs: generate-video
    if: always() && secrets.TELEGRAM_BOT_TOKEN
    
    steps:
      - name: Send notification
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          FORMAT: ${{ github.event.inputs.format || 'shorts' }}
          STATUS: ${{ needs.generate-video.result }}
        run: |
          if [ "$STATUS" = "success" ]; then
            EMOJI="‚úÖ"
            TEXT="Horoscope video generated successfully"
          else
            EMOJI="‚ùå"
            TEXT="Horoscope video generation failed"
          fi
          
          MESSAGE="$EMOJI $TEXT%0AFormat: $FORMAT%0AWorkflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          curl -s -X POST \
            -H 'Content-Type: application/x-www-form-urlencoded' \
            -d "chat_id=$TELEGRAM_CHAT_ID&text=$MESSAGE&parse_mode=HTML" \
            "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage" > /dev/null
