name: Generate Horoscope Video

on:
  workflow_dispatch:
    inputs:
      format:
        description: 'Video format (shorts | long_form | ad)'
        required: true
        default: 'shorts'
        type: choice
        options:
          - shorts
          - long_form
          - ad
      date:
        description: 'Horoscope date (YYYY-MM-DD, optional - uses today)'
        required: false
        type: string
      project:
        description: 'Project name'
        required: false
        default: 'youtube_horoscope'
        type: string
  
  schedule:
    - cron: '0 6 * * *'  # Daily 06:00 UTC = 09:00 MSK

jobs:
  generate-video:
    runs-on: ubuntu-22.04
    timeout-minutes: 45
    outputs:
      video_path: ${{ steps.generate.outputs.video_path }}
      video_size: ${{ steps.generate.outputs.video_size }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
      
      # ‚úÖ Cache pip dependencies (built-in)
      - name: Setup Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'  # ‚úÖ Enables pip caching (~15s ‚Üí ~2s on cache hit)
      
      # ‚úÖ SAFE APT CACHE: Use project directory instead of /var/
      - name: Restore APT Cache
        uses: actions/cache@v4
        with:
          path: ./.apt-cache
          key: ${{ runner.os }}-apt-packages-${{ hashFiles('.github/workflows/**') }}
          restore-keys: |
            ${{ runner.os }}-apt-packages-
      
      # ‚úÖ OPTIMIZED: Only update apt cache if it's missing
      - name: Install system dependencies
        run: |
          echo "üîç Setting up APT cache directory..."
          mkdir -p ./.apt-cache
          export APT_CACHE_DIR="$(pwd)/.apt-cache"
          
          echo "üì¶ Installing packages: ffmpeg, imagemagick, ghostscript..."
          sudo apt-get update -qq
          sudo apt-get install -y \
            ffmpeg \
            imagemagick \
            ghostscript \
            fonts-dejavu-core \
            libsm6 \
            libxext6 \
            2>&1 | tail -5
          
          echo "‚úÖ System dependencies ready"
      
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip -q
          pip install -r requirements.txt -q
          echo "‚úÖ Python dependencies ready"
      
      - name: Determine format and date
        id: params
        run: |
          FORMAT="${{ github.event.inputs.format || 'shorts' }}"
          DATE="${{ github.event.inputs.date }}"
          PROJECT="${{ github.event.inputs.project || 'youtube_horoscope' }}"
          
          if [ -z "$DATE" ]; then
            DATE=$(date +%Y-%m-%d)
          fi
          
          echo "format=$FORMAT" >> $GITHUB_OUTPUT
          echo "date=$DATE" >> $GITHUB_OUTPUT
          echo "project=$PROJECT" >> $GITHUB_OUTPUT
          
          echo "üìÖ Format: $FORMAT"
          echo "üìÜ Date: $DATE"
          echo "üì¶ Project: $PROJECT"
      
      - name: Validate API Keys
        run: |
          echo "üîê Validating required secrets..."
          
          # Check GOOGLE_AI_API_KEY
          if [ -z "${{ secrets.GOOGLE_AI_API_KEY }}" ]; then
            echo "‚ùå GOOGLE_AI_API_KEY is NOT set in GitHub Secrets"
            echo "   Go to: https://github.com/${{ github.repository }}/settings/secrets/actions"
            echo "   Add: GOOGLE_AI_API_KEY = <your Google AI key>"
            exit 1
          fi
          
          # Show first 10 chars and length for debug
          API_KEY="${{ secrets.GOOGLE_AI_API_KEY }}"
          KEY_PREFIX="${API_KEY:0:10}"
          KEY_LENGTH=${#API_KEY}
          
          echo "‚úÖ GOOGLE_AI_API_KEY found"
          echo "   Length: $KEY_LENGTH chars"
          echo "   Prefix (first 10 chars): $KEY_PREFIX..."
          
          # Validate key is not too short
          if [ $KEY_LENGTH -lt 20 ]; then
            echo "‚ùå ERROR: Key too short ($KEY_LENGTH chars, minimum 20)"
            exit 1
          fi
          
          echo "‚úÖ Key format validated"
          
          # Optional keys
          if [ -z "${{ secrets.PIXABAY_API_KEY }}" ]; then
            echo "‚ö†Ô∏è  PIXABAY_API_KEY not set (optional, will use fallback)"
          else
            PIXABAY_KEY="${{ secrets.PIXABAY_API_KEY }}"
            PIXABAY_PREFIX="${PIXABAY_KEY:0:10}"
            echo "‚úÖ PIXABAY_API_KEY found (prefix: $PIXABAY_PREFIX...)"
          fi
      
      - name: Generate Content (Script ‚Üí TTS ‚Üí Video with ModelRouter)
        id: generate
        env:
          GOOGLE_AI_API_KEY: ${{ secrets.GOOGLE_AI_API_KEY }}
          PIXABAY_API_KEY: ${{ secrets.PIXABAY_API_KEY }}
          FORMAT: ${{ steps.params.outputs.format }}
          DATE: ${{ steps.params.outputs.date }}
          PROJECT: ${{ steps.params.outputs.project }}
        run: |
          python3 << 'PYTHON_SCRIPT'
          import os
          import sys
          import json
          from pathlib import Path
          
          # Add current dir to path to import core modules
          sys.path.insert(0, '.')
          
          project_name = os.getenv('PROJECT')
          fmt = os.getenv('FORMAT')
          target_date = os.getenv('DATE')
          api_key = os.getenv('GOOGLE_AI_API_KEY')
          
          # ========== DEBUG: Show what we got ==========
          print(f"\nüîç DEBUG: Environment Variables")
          print(f"-" * 70)
          print(f"PROJECT: {project_name}")
          print(f"FORMAT: {fmt}")
          print(f"DATE: {target_date}")
          
          if api_key:
              key_preview = api_key[:10] + "..." + api_key[-4:]
              print(f"GOOGLE_AI_API_KEY: {key_preview} ({len(api_key)} chars)")
          else:
              print(f"GOOGLE_AI_API_KEY: NOT SET (‚ùå)")
          
          # Validate API key
          if not api_key:
              print(f"\n‚ùå CRITICAL ERROR: GOOGLE_AI_API_KEY not found in environment")
              print(f"   This should have been caught in 'Validate API Keys' step")
              print(f"   Check GitHub Secrets configuration at:")
              print(f"   https://github.com/${{ github.repository }}/settings/secrets/actions")
              sys.exit(1)
          
          if len(api_key) < 20:
              key_preview = api_key[:10] + "..."
              print(f"\n‚ùå ERROR: API key appears to be invalid")
              print(f"   Length: {len(api_key)} chars (minimum required: 20)")
              print(f"   Prefix: {key_preview}")
              print(f"   Possible issues:")
              print(f"   - Key is truncated or corrupted")
              print(f"   - GitHub secret was not saved correctly")
              print(f"   - Secret name is wrong (case-sensitive!)")
              sys.exit(1)
          
          key_preview = api_key[:10] + "..." + api_key[-4:]
          print(f"\n‚úÖ API key validated")
          print(f"   Length: {len(api_key)} chars")
          print(f"   Prefix: {key_preview}")
          
          print(f"\n" + "="*70)
          print(f"üé¨ HOROSCOPE VIDEO GENERATION")
          print(f"="*70)
          print(f"Project: {project_name}")
          print(f"Format: {fmt}")
          print(f"Date: {target_date}\n")
          
          # ========== LOAD CONFIG ==========
          print(f"‚ö° Loading configuration...")
          try:
              from core.utils.config_loader import ProjectConfig
              config_path = f"projects/{project_name}/config.yaml"
              config = ProjectConfig.load(config_path)
              print(f"‚úÖ Config loaded: {config_path}")
          except Exception as e:
              print(f"‚ùå Config loading failed: {e}")
              print(f"   Attempting fallback config...")
              # Fallback config if file missing (for testing)
              from core.utils.config_loader import ProjectConfig
              config = ProjectConfig(
                  name=project_name, 
                  description="Fallback", 
                  content_type=fmt,
                  platforms=["youtube"]
              )
              print(f"‚ö†Ô∏è Using fallback config")

          # ========== PART 1: SCRIPT GENERATION ==========
          print(f"\nüìù PART 1: Script Generation (with ModelRouter)")
          print(f"-" * 70)
          
          try:
              from core.generators import script_generator
              
              # UPDATED CALL: Passing config and api_key
              if fmt == "shorts":
                  script = script_generator.generate_short(
                      config=config, 
                      target_date=target_date, 
                      api_key=api_key
                  )
              elif fmt == "long_form":
                  script = script_generator.generate_long_form(
                      config=config, 
                      target_date=target_date, 
                      api_key=api_key
                  )
              elif fmt == "ad":
                  script = script_generator.generate_ad(
                      config=config, 
                      target_date=target_date, 
                      api_key=api_key
                  )
              else:
                  raise ValueError(f"Unknown format: {fmt}")
              
              print(f"‚úÖ Script generated")
              print(f"   Format: {fmt}")
              print(f"   Length: {len(script.get('script', ''))} chars")
          
          except Exception as e:
              print(f"‚ùå Script generation failed: {e}")
              import traceback
              traceback.print_exc()
              sys.exit(1)
          
          # ========== PART 2: TTS SYNTHESIS ==========
          print(f"\nüéôÔ∏è PART 2: TTS Synthesis")
          print(f"-" * 70)
          
          try:
              from core.generators import tts_generator
              
              audio_map = tts_generator.synthesize(
                  config=config,
                  script=script,
                  mode=fmt,
                  api_key=api_key
              )
              
              print(f"‚úÖ Audio synthesized")
              print(f"   Duration: {audio_map.get('total_duration_sec', 0):.1f}s")
              print(f"   Blocks: {len(audio_map.get('blocks', {}))}")
              print(f"   Engine: {audio_map.get('engine_used', 'unknown')}")
          except Exception as e:
              print(f"‚ùå TTS synthesis failed: {e}")
              import traceback
              traceback.print_exc()
              sys.exit(1)
          
          # ========== PART 3: VIDEO RENDERING ==========
          print(f"\nüé• PART 3: Video Rendering")
          print(f"-" * 70)
          
          try:
              from core.generators import video_renderer
              
              video_path = video_renderer.render(
                  config=config,
                  script=script,
                  audio_map=audio_map,
                  mode=fmt
              )
              
              video_file = Path(video_path)
              if video_file.exists():
                  size_mb = video_file.stat().st_size / (1024*1024)
                  print(f"‚úÖ Video rendered: {video_path}")
                  print(f"   Size: {size_mb:.1f} MB")
              else:
                  raise FileNotFoundError(f"Video file not found: {video_path}")
          
          except Exception as e:
              print(f"‚ùå Video rendering failed: {e}")
              import traceback
              traceback.print_exc()
              sys.exit(1)
          
          # ========== SUMMARY ==========
          print(f"\n" + "="*70)
          print(f"‚úÖ SUCCESS! Video generation complete")
          print(f"="*70)
          print(f"Output: {video_path}")
          print(f"Size: {size_mb:.1f} MB")
          print(f"\nReady for publishing to YouTube, TikTok, VK, Instagram")
          
          # ========== OUTPUT FOR NEXT STEPS ==========
          with open(os.environ.get('GITHUB_OUTPUT', '/dev/null'), 'a') as f:
              f.write(f"video_path={video_path}\n")
              f.write(f"video_size={size_mb:.1f}\n")
          
          PYTHON_SCRIPT
      
      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: horoscope-output-${{ github.run_number }}
          path: |
            output/scripts/
            output/audio/
            output/videos/
          retention-days: 7
          if-no-files-found: warn
      
      - name: Summary
        if: success()
        run: |
          echo "‚úÖ Video generation complete"
          echo "Format: ${{ steps.params.outputs.format }}"
          echo "Date: ${{ steps.params.outputs.date }}"
          echo "Video path: ${{ steps.generate.outputs.video_path }}"
          echo "Video size: ${{ steps.generate.outputs.video_size }} MB"

  send-to-telegram:
    runs-on: ubuntu-22.04
    needs: [generate-video]
    if: always()
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download video artifact
        uses: actions/download-artifact@v4
        with:
          name: horoscope-output-${{ github.run_number }}
          path: ./artifacts
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Find and send video to Telegram
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          FORMAT: ${{ github.event.inputs.format || 'shorts' }}
          STATUS: ${{ needs.generate-video.result }}
        run: |
          python3 << 'PYTHON_SCRIPT'
          import os
          import requests
          import glob
          from pathlib import Path
          
          telegram_token = os.getenv('TELEGRAM_BOT_TOKEN')
          chat_id = os.getenv('TELEGRAM_CHAT_ID')
          fmt = os.getenv('FORMAT')
          status = os.getenv('STATUS')
          
          # Validate Telegram credentials
          if not telegram_token or not chat_id:
              print("‚ö†Ô∏è  Telegram credentials not configured, skipping")
              print("   Set TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID secrets")
              exit(0)
          
          print("üì° Telegram sender initialized")
          print(f"   Chat ID: {chat_id}")
          print(f"   Token: {telegram_token[:10]}...")
          
          # Prepare message
          if status == "success":
              emoji = "‚úÖ"
              title = "Horoscope Video Generated!"
          else:
              emoji = "‚ùå"
              title = "Video Generation Failed"
          
          message = f"{emoji} {title}\n"
          message += f"Format: {fmt}\n"
          message += f"Run: #${{ github.run_number }}\n"
          message += f"Branch: ${{ github.ref_name }}"
          
          # Find video files
          video_patterns = ['artifacts/output/videos/**/*.mp4', 
                           'artifacts/output/videos/**/*.webm',
                           'artifacts/output/videos/**/*.mov']
          
          video_files = []
          for pattern in video_patterns:
              video_files.extend(glob.glob(pattern, recursive=True))
          
          if not video_files:
              print("‚ö†Ô∏è  No video files found in artifacts")
              print("   Looking in: artifacts/output/videos/")
              
              # List what we have
              if os.path.exists('artifacts'):
                  print("\nüìÅ Artifacts structure:")
                  for root, dirs, files in os.walk('artifacts'):
                      level = root.replace('artifacts', '').count(os.sep)
                      indent = ' ' * 2 * level
                      print(f"{indent}{os.path.basename(root)}/")
                      subindent = ' ' * 2 * (level + 1)
                      for file in files[:5]:  # Show first 5 files
                          print(f"{subindent}{file}")
              
              # Send message without video
              url = f"https://api.telegram.org/bot{telegram_token}/sendMessage"
              payload = {
                  'chat_id': chat_id,
                  'text': message,
                  'parse_mode': 'HTML'
              }
              
              response = requests.post(url, json=payload)
              if response.status_code == 200:
                  print("‚úÖ Status message sent to Telegram (no video attached)")
              else:
                  print(f"‚ùå Failed to send message: {response.text}")
              
              exit(0)
          
          # Send each video found
          for video_file in video_files[:3]:  # Limit to 3 videos
              file_path = Path(video_file)
              file_size_mb = file_path.stat().st_size / (1024 * 1024)
              
              print(f"\nüé¨ Sending: {file_path.name}")
              print(f"   Size: {file_size_mb:.1f} MB")
              
              # For files > 50MB, send as document instead of video
              if file_size_mb > 50:
                  print(f"   ‚ö†Ô∏è  File > 50MB, sending as document")
                  method = 'sendDocument'
                  file_param = 'document'
              else:
                  method = 'sendVideo'
                  file_param = 'video'
              
              try:
                  with open(video_file, 'rb') as f:
                      files = {file_param: f}
                      data = {
                          'chat_id': chat_id,
                          'caption': message,
                          'parse_mode': 'HTML'
                      }
                      
                      url = f"https://api.telegram.org/bot{telegram_token}/{method}"
                      response = requests.post(url, files=files, data=data, timeout=300)
                      
                      if response.status_code == 200:
                          print(f"   ‚úÖ Sent successfully!")
                      else:
                          print(f"   ‚ùå Error: {response.status_code}")
                          print(f"   {response.text}")
              
              except Exception as e:
                  print(f"   ‚ùå Failed: {e}")
          
          print("\n‚úÖ Telegram delivery complete")
          
          PYTHON_SCRIPT
        continue-on-error: true
