name: AI Code Review with Gemini CLI

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - main
      - develop

  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to review (optional, for manual runs)'
        required: false
        type: string

      base_ref:
        description: 'Base ref for diff if no PR (e.g., main)'
        required: false
        default: 'main'
        type: string

permissions:
  contents: write
  pull-requests: write
  checks: write
  id-token: write  # Required for OIDC authentication with Google

jobs:
  ai-code-review:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      # Step 1: Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ github.token }}

      # Step 2: Determine PR context
      - name: Determine PR context
        id: pr_context
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            # Automatic trigger from PR event
            PR_NUMBER=${{ github.event.pull_request.number }}
            BASE_SHA=${{ github.event.pull_request.base.sha }}
            HEAD_SHA=${{ github.event.pull_request.head.sha }}
            HEAD_REF=${{ github.event.pull_request.head.ref }}
            PR_TITLE="${{ github.event.pull_request.title }}"
            PR_BODY="${{ github.event.pull_request.body }}"
            
            echo "‚úì Triggered from PR event (auto)"
          else
            # Manual workflow_dispatch trigger
            if [ -n "${{ inputs.pr_number }}" ]; then
              # Get PR metadata from GitHub API
              PR_NUMBER="${{ inputs.pr_number }}"
              PR_DATA=$(gh api repos/${{ github.repository }}/pulls/$PR_NUMBER)
              
              PR_TITLE=$(echo "$PR_DATA" | jq -r '.title')
              PR_BODY=$(echo "$PR_DATA" | jq -r '.body // ""')
              BASE_SHA=$(echo "$PR_DATA" | jq -r '.base.sha')
              HEAD_SHA=$(echo "$PR_DATA" | jq -r '.head.sha')
              HEAD_REF=$(echo "$PR_DATA" | jq -r '.head.ref')
              
              # Checkout PR branch
              git fetch origin $HEAD_REF
              git checkout -B $HEAD_REF origin/$HEAD_REF
              
              echo "‚úì Triggered from workflow_dispatch with PR #$PR_NUMBER"
            else
              # Manual workflow_dispatch without PR - use base_ref and current HEAD
              BASE_REF="${{ inputs.base_ref }}"
              git fetch origin $BASE_REF
              
              BASE_SHA=$(git rev-parse origin/$BASE_REF)
              HEAD_SHA=$(git rev-parse HEAD)
              HEAD_REF=$(git rev-parse --abbrev-ref HEAD)
              PR_NUMBER="0"
              PR_TITLE="Manual code review on $HEAD_REF"
              PR_BODY=""
              
              echo "‚úì Triggered from workflow_dispatch without PR (comparing with $BASE_REF)"
            fi
          fi

          # Export outputs
          echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "BASE_SHA=$BASE_SHA" >> $GITHUB_OUTPUT
          echo "HEAD_SHA=$HEAD_SHA" >> $GITHUB_OUTPUT
          echo "HEAD_REF=$HEAD_REF" >> $GITHUB_OUTPUT
          echo "PR_TITLE=$PR_TITLE" >> $GITHUB_OUTPUT
          echo "PR_BODY<<EOF" >> $GITHUB_OUTPUT
          echo "$PR_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Debug output
          echo ""
          echo "üìã PR Context Determined:"
          echo "  PR_NUMBER: $PR_NUMBER"
          echo "  BASE_SHA: ${BASE_SHA:0:8}"
          echo "  HEAD_SHA: ${HEAD_SHA:0:8}"
          echo "  HEAD_REF: $HEAD_REF"
          echo "  PR_TITLE: $PR_TITLE"

      # Step 3: Setup Node.js for Gemini CLI
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      # Step 4: Setup Google OIDC for authentication (via official Action)
      - name: Setup Google OIDC
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GOOGLE_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GOOGLE_SERVICE_ACCOUNT }}
        if: false # We'll use the official Action which handles auth internally

      # Step 5: Prepare materials for Gemini CLI
      - name: Prepare materials for Gemini CLI
        id: prepare
        env:
          GH_TOKEN: ${{ github.token }}
          BASE_SHA: ${{ steps.pr_context.outputs.BASE_SHA }}
          HEAD_SHA: ${{ steps.pr_context.outputs.HEAD_SHA }}
          PR_NUMBER: ${{ steps.pr_context.outputs.PR_NUMBER }}
          PR_BODY: ${{ steps.pr_context.outputs.PR_BODY }}
        run: |
          set -e
          
          # Create working directory
          mkdir -p .gemini
          
          echo "üìù Preparing materials for review..."
          
          # 1. Extract issue number from PR description (format: #NUMBER or Fixes #NUMBER)
          ISSUE_NUMBER=$(echo "$PR_BODY" | grep -oE '#[0-9]+' | head -1 | tr -d '#' || echo "")
          
          echo "ISSUE_NUMBER=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
          
          if [ -n "$ISSUE_NUMBER" ]; then
            echo "‚úì Found issue #$ISSUE_NUMBER in PR description"
            
            # Get issue content via GitHub API
            ISSUE_DATA=$(gh api repos/${{ github.repository }}/issues/$ISSUE_NUMBER 2>/dev/null || echo "{}")
            ISSUE_TITLE=$(echo "$ISSUE_DATA" | jq -r '.title // "Issue details"')
            ISSUE_BODY=$(echo "$ISSUE_DATA" | jq -r '.body // ""')
            
            # Save issue to file
            cat > .gemini/issue.md << 'ISSUE_EOF'
          # Issue Details
          
          ISSUE_EOF
            
            echo "## #$ISSUE_NUMBER - $ISSUE_TITLE" >> .gemini/issue.md
            echo "" >> .gemini/issue.md
            echo "$ISSUE_BODY" >> .gemini/issue.md
            
            echo "‚úì Issue saved to .gemini/issue.md"
          else
            echo "‚ö†Ô∏è  No issue number found in PR description"
            echo "# No issue linked to this PR" > .gemini/issue.md
          fi
          
          # 2. Save PR description
          cat > .gemini/pr-description.md << 'PR_DESC_EOF'
          # Pull Request Description
          
          PR_DESC_EOF
          
          echo "$PR_BODY" >> .gemini/pr-description.md
          echo "‚úì PR description saved to .gemini/pr-description.md"
          
          # 3. Generate diff
          echo "Generating diff from $BASE_SHA to $HEAD_SHA..."
          git diff "$BASE_SHA..$HEAD_SHA" > .gemini/diff.patch || {
            # Fallback if commit range doesn't work
            git diff HEAD > .gemini/diff.patch
          }
          
          DIFF_SIZE=$(wc -c < .gemini/diff.patch)
          echo "‚úì Diff generated: $DIFF_SIZE bytes"
          
          if [ $DIFF_SIZE -eq 0 ]; then
            echo "‚ö†Ô∏è  No changes detected in diff"
          fi
          
          # 4. Save list of changed files
          git diff --name-only "$BASE_SHA..$HEAD_SHA" 2>/dev/null > .gemini/changed_files.txt || {
            git diff --name-only HEAD^ HEAD > .gemini/changed_files.txt
          }
          
          CHANGED_COUNT=$(wc -l < .gemini/changed_files.txt)
          echo "‚úì Changed files: $CHANGED_COUNT files"
          
          # 5. Display what we're working with
          echo ""
          echo "üìä Materials prepared:"
          echo "  - Issue: $([ -s .gemini/issue.md ] && echo 'Yes' || echo 'No')"
          echo "  - PR description: $([ -s .gemini/pr-description.md ] && echo 'Yes' || echo 'No')"
          echo "  - Diff: $([ -s .gemini/diff.patch ] && echo 'Yes' || echo 'No')"
          echo "  - Changed files: $([ -s .gemini/changed_files.txt ] && echo 'Yes' || echo 'No')"

      # ‚≠ê STEP 5: RUN GEMINI CLI CODE REVIEW (–ì–õ–ê–í–ù–û–ï!)
      - name: Run Gemini CLI code review
        id: review
        uses: google-github-actions/run-gemini-cli@v0.2.0
        with:
          prompt: |
            # –ò–ù–°–¢–†–£–ö–¶–ò–Ø –î–õ–Ø AI –ê–ì–ï–ù–¢–ê
            @.github/gemini/code-review-prompt.md
            
            # –†–ï–ê–õ–¨–ù–û–ï –¢–ó –ò–ó GITHUB ISSUE (–∏—Å—Ç–æ—á–Ω–∏–∫ –ø—Ä–∞–≤–¥—ã)
            @.gemini/issue.md
            
            # –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ô –ö–û–ù–¢–ï–ö–°–¢: –û–ü–ò–°–ê–ù–ò–ï PR
            @.gemini/pr-description.md
            
            # –ö–û–î –î–õ–Ø –ê–ù–ê–õ–ò–ó–ê: DIFF PR
            @.gemini/diff.patch
            
            # –ò–ù–°–¢–†–£–ö–¶–ò–Ø: –í–´–ü–û–õ–ù–ò –í–°–ï –®–ê–ì–ò –ê–ù–ê–õ–ò–ó–ê –ò –£–õ–£–ß–®–ï–ù–ò–ô
            
            –¢—ã AI Code Reviewer & Auto-Fixer –¥–ª—è —ç—Ç–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞.
            
            –¢–≤–æ—è –∑–∞–¥–∞—á–∞:
            1. –ü—Ä–æ—á–∏—Ç–∞–π –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é –≤ @.github/gemini/code-review-prompt.md
            2. –ü—Ä–æ—á–∏—Ç–∞–π —Ä–µ–∞–ª—å–Ω–æ–µ –¢–ó –≤ @.gemini/issue.md (–µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π)
            3. –ü—Ä–æ—á–∏—Ç–∞–π diff PR (@.gemini/diff.patch) —á—Ç–æ–±—ã –ø–æ–Ω—è—Ç—å —á—Ç–æ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å
            4. –°–ª–µ–¥—É–π –≤—Å–µ–º —à–∞–≥–∞–º –∏–∑ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏: –∞–Ω–∞–ª–∏–∑ ‚Üí –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ ‚Üí –ø—Ä–∞–≤–∫–∏ ‚Üí –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è
            5. –ü—Ä–∞–≤—å —Ñ–∞–π–ª—ã –ø—Ä—è–º–æ –≤ —Ç–µ–∫—É—â–µ–π –≤–µ—Ç–∫–µ (–≤—Å–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –±—É–¥—É—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–∫–æ–º–º–∏—á–µ–Ω—ã)
            6. –î–æ–±–∞–≤–ª—è–π —Ç–µ—Å—Ç—ã, –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é, —É–ª—É—á—à–∞–π –∫–æ–¥ –∫–∞—á–µ—Å—Ç–≤–æ
            7. –ù–µ –ø—Ä–∏–¥—É–º—ã–≤–∞–π —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è - —Ä–∞–±–æ—Ç–∞–π —Ç–æ–ª—å–∫–æ —Å —Ç–µ–º —á—Ç–æ –≤ issue
            8. –ï—Å–ª–∏ –Ω–µ–æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ—Å—Ç—å - —Å–ø—Ä–æ—Å–∏ –≤ PR –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ (–Ω–µ –≥–∞–¥–∞–π)
          
          allow-no-changes: true
          auto-commit: false  # We'll do manual commit to control message

      # STEP 6: Auto-fix: Commit and push changes (if any)
      - name: Commit and push changes to PR branch
        id: commit
        if: always()
        env:
          HEAD_REF: ${{ steps.pr_context.outputs.HEAD_REF }}
        run: |
          # Check for uncommitted changes
          if git diff --quiet; then
            echo "‚úì No changes detected by AI Agent"
            echo "HAS_CHANGES=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "üîß AI Agent detected changes to commit"
          
          # Check if we have any staged changes
          git add -A
          
          if git diff --cached --quiet; then
            echo "‚úì No staged changes to commit"
            echo "HAS_CHANGES=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Configure git
          git config user.name "AI Code Review Agent"
          git config user.email "ai-review@github.local"
          
          # Get list of changed files
          CHANGED=$(git diff --cached --name-only | xargs echo "Modified files:" || echo "")
          
          # Create commit message
          COMMIT_MSG="fix: auto-improvements by Gemini CLI AI Agent

          - Code quality improvements
          - Missing tests and documentation added
          - Checklist items completed where possible
          - Code style and formatting fixes"
          
          # Commit changes
          git commit -m "$COMMIT_MSG" || {
            echo "‚ö†Ô∏è  Commit failed - no changes to commit"
            echo "HAS_CHANGES=false" >> $GITHUB_OUTPUT
            exit 0
          }
          
          echo "‚úì Changes committed"
          
          # Push to PR branch
          git push origin "$HEAD_REF" || {
            echo "‚ùå Failed to push changes"
            exit 1
          }
          
          echo "‚úì Changes pushed to origin/$HEAD_REF"
          echo "HAS_CHANGES=true" >> $GITHUB_OUTPUT
          echo "COMMIT_MSG<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMIT_MSG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # STEP 7: Post review summary to PR
      - name: Post review summary to PR
        if: always() && steps.pr_context.outputs.PR_NUMBER != '0'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            let reviewData = {};
            
            // Try to read review results from .gemini directory
            const reviewPath = '.gemini/review-result.json';
            
            if (fs.existsSync(reviewPath)) {
              try {
                const content = fs.readFileSync(reviewPath, 'utf8');
                reviewData = JSON.parse(content);
                console.log('‚úì Review data loaded successfully');
              } catch (e) {
                console.log('‚ö†Ô∏è  Could not parse review JSON:', e.message);
                reviewData = {
                  overall_rating: '‚ö†Ô∏è REVIEW',
                  summary: 'Code review completed - JSON parsing failed',
                  issues: [],
                  improvements: [],
                  checklist_items: [],
                  files_modified: []
                };
              }
            } else {
              console.log('‚ö†Ô∏è  Review result file not found');
              reviewData = {
                overall_rating: '‚ö†Ô∏è REVIEW',
                summary: 'Code review completed by Gemini CLI',
                issues: [],
                improvements: ['Review completed by AI agent'],
                checklist_items: [],
                files_modified: []
              };
            }
            
            // Build markdown comment
            let comment = `## ü§ñ AI Code Review Summary\n\n`;
            
            const prNumber = context.issue.number;
            const issueNum = reviewData.issue_number || 0;
            
            // Issue reference
            if (issueNum > 0) {
              comment += `**Issue:** #${issueNum}\n\n`;
            }
            
            // Overall rating
            const rating = reviewData.overall_rating || '‚ö†Ô∏è REVIEW';
            comment += `**Overall Rating:** ${rating}\n\n`;
            
            // Summary
            if (reviewData.summary) {
              comment += `**Summary:** ${reviewData.summary}\n\n`;
            }
            
            // Checklist items
            if (reviewData.checklist_items && reviewData.checklist_items.length > 0) {
              comment += `### ‚úÖ Checklist Status\n`;
              reviewData.checklist_items.forEach(item => {
                const icon = item.status === 'completed' ? '‚úÖ' :
                            item.status === 'incomplete' ? '‚ùå' : '‚ö†Ô∏è';
                comment += `${icon} ${item.item}`;
                if (item.reason) {
                  comment += ` - ${item.reason}`;
                }
                comment += `\n`;
              });
              comment += `\n`;
            }
            
            // Issues found
            if (reviewData.issues && reviewData.issues.length > 0) {
              comment += `### üö® Issues Found\n`;
              reviewData.issues.forEach(issue => {
                const icon = issue.severity === 'critical' ? 'üî¥' :
                            issue.severity === 'warning' ? 'üü°' : 'üîµ';
                comment += `\n${icon} **${issue.severity.toUpperCase()}** in \`${issue.file}\`\n`;
                comment += `> ${issue.message}\n`;
                if (issue.suggestion) {
                  comment += `üí° ${issue.suggestion}\n`;
                }
              });
              comment += `\n`;
            }
            
            // Improvements
            if (reviewData.improvements && reviewData.improvements.length > 0) {
              comment += `### üí° Improvements Suggested\n`;
              reviewData.improvements.forEach(imp => {
                comment += `- ${imp}\n`;
              });
              comment += `\n`;
            }
            
            // Files modified by AI
            if (reviewData.files_modified && reviewData.files_modified.length > 0) {
              comment += `### üìù Files Modified by AI Agent\n`;
              reviewData.files_modified.forEach(file => {
                comment += `- \`${file}\`\n`;
              });
              comment += `\n`;
            }
            
            // Status of AI changes
            const hasChanges = '${{ steps.commit.outputs.HAS_CHANGES }}' === 'true';
            comment += `### ‚ÑπÔ∏è AI Agent Status\n`;
            comment += `- Auto-fixes applied: ${hasChanges ? '‚úÖ Yes' : '‚ùå No'}\n`;
            if (hasChanges) {
              comment += `- Commit: auto-improvements by Gemini CLI AI Agent\n`;
            }
            comment += `\n`;
            
            // Fallback: show raw response if JSON parsing failed
            if (Object.keys(reviewData).length === 0 && reviewRaw) {
              comment += `### üìã Review Details\n`;
              comment += `\`\`\`\n`;
              comment += reviewRaw.substring(0, 2000);
              comment += `\n\`\`\`\n\n`;
            }
            
            // Footer
            comment += `---\n`;
            comment += `*Auto-generated by Gemini CLI AI Agent*\n`;
            
            // Post comment
            try {
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
              console.log('‚úì Comment posted to PR #' + context.issue.number);
            } catch (error) {
              console.log('‚ö†Ô∏è  Could not post comment:', error.message);
            }

      # STEP 9: Debug outputs
      - name: Show review results
        if: always()
        run: |
          echo "üìã Review Results:"
          echo ""
          
          if [ -f ".gemini/review-result.json" ]; then
            echo "JSON Result:"
            cat .gemini/review-result.json | jq . 2>/dev/null || cat .gemini/review-result.json
          else
            echo "‚ö†Ô∏è  No JSON result file found"
          fi
          
          echo ""
          echo "üìÅ Materials in .gemini/:"
          ls -la .gemini/ 2>/dev/null || echo "No .gemini directory found"
          
          echo ""
          echo "üìä Files Modified by AI Agent:"
          git status --porcelain || echo "No git changes detected"
          
          echo ""
          echo "üîç Current Branch:"
          git branch --show-current
          
          echo ""
          echo "‚úÖ Gemini CLI execution completed!"
