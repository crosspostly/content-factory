name: AI Code Review with Gemini CLI

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - main
      - develop

  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to review (optional, for manual runs)'
        required: false
        type: string

      base_ref:
        description: 'Base ref for diff if no PR (e.g., main)'
        required: false
        default: 'main'
        type: string

permissions:
  contents: write
  pull-requests: write
  checks: write

jobs:
  ai-code-review:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      # Step 1: Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ github.token }}

      # Step 2: Determine PR context
      - name: Determine PR context
        id: pr_context
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            # Automatic trigger from PR event
            PR_NUMBER=${{ github.event.pull_request.number }}
            BASE_SHA=${{ github.event.pull_request.base.sha }}
            HEAD_SHA=${{ github.event.pull_request.head.sha }}
            HEAD_REF=${{ github.event.pull_request.head.ref }}
            PR_TITLE="${{ github.event.pull_request.title }}"
            PR_BODY="${{ github.event.pull_request.body }}"
            
            echo "‚úì Triggered from PR event (auto)"
          else
            # Manual workflow_dispatch trigger
            if [ -n "${{ inputs.pr_number }}" ]; then
              # Get PR metadata from GitHub API
              PR_NUMBER="${{ inputs.pr_number }}"
              PR_DATA=$(gh api repos/${{ github.repository }}/pulls/$PR_NUMBER)
              
              PR_TITLE=$(echo "$PR_DATA" | jq -r '.title')
              PR_BODY=$(echo "$PR_DATA" | jq -r '.body // ""')
              BASE_SHA=$(echo "$PR_DATA" | jq -r '.base.sha')
              HEAD_SHA=$(echo "$PR_DATA" | jq -r '.head.sha')
              HEAD_REF=$(echo "$PR_DATA" | jq -r '.head.ref')
              
              # Checkout PR branch
              git fetch origin $HEAD_REF
              git checkout -B $HEAD_REF origin/$HEAD_REF
              
              echo "‚úì Triggered from workflow_dispatch with PR #$PR_NUMBER"
            else
              # Manual workflow_dispatch without PR - use base_ref and current HEAD
              BASE_REF="${{ inputs.base_ref }}"
              git fetch origin $BASE_REF
              
              BASE_SHA=$(git rev-parse origin/$BASE_REF)
              HEAD_SHA=$(git rev-parse HEAD)
              HEAD_REF=$(git rev-parse --abbrev-ref HEAD)
              PR_NUMBER="0"
              PR_TITLE="Manual code review on $HEAD_REF"
              PR_BODY=""
              
              echo "‚úì Triggered from workflow_dispatch without PR (comparing with $BASE_REF)"
            fi
          fi

          # Export outputs
          echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "BASE_SHA=$BASE_SHA" >> $GITHUB_OUTPUT
          echo "HEAD_SHA=$HEAD_SHA" >> $GITHUB_OUTPUT
          echo "HEAD_REF=$HEAD_REF" >> $GITHUB_OUTPUT
          echo "PR_TITLE=$PR_TITLE" >> $GITHUB_OUTPUT
          echo "PR_BODY<<EOF" >> $GITHUB_OUTPUT
          echo "$PR_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Debug output
          echo ""
          echo "üìã PR Context Determined:"
          echo "  PR_NUMBER: $PR_NUMBER"
          echo "  BASE_SHA: ${BASE_SHA:0:8}"
          echo "  HEAD_SHA: ${HEAD_SHA:0:8}"
          echo "  HEAD_REF: $HEAD_REF"
          echo "  PR_TITLE: $PR_TITLE"

      # Step 3: Setup Node.js for Gemini CLI
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      # Step 4: Install Gemini CLI
      - name: Install Gemini CLI
        run: |
          echo "üì¶ Installing Gemini CLI..."
          npm install -g @google/genai
          
          # Verify installation
          genai --version || {
            echo "‚ö†Ô∏è  npx fallback: genai not found globally, will use npx"
            npm list -g @google/genai || echo "Installing via npx approach"
          }
          
          echo "‚úì Gemini CLI ready"

      # Step 5: Prepare materials for Gemini CLI
      - name: Prepare materials for Gemini CLI
        id: prepare
        env:
          GH_TOKEN: ${{ github.token }}
          BASE_SHA: ${{ steps.pr_context.outputs.BASE_SHA }}
          HEAD_SHA: ${{ steps.pr_context.outputs.HEAD_SHA }}
          PR_NUMBER: ${{ steps.pr_context.outputs.PR_NUMBER }}
          PR_BODY: ${{ steps.pr_context.outputs.PR_BODY }}
        run: |
          set -e
          
          # Create working directory
          mkdir -p .gemini
          
          echo "üìù Preparing materials for review..."
          
          # 1. Extract issue number from PR description (format: #NUMBER or Fixes #NUMBER)
          ISSUE_NUMBER=$(echo "$PR_BODY" | grep -oE '#[0-9]+' | head -1 | tr -d '#' || echo "")
          
          echo "ISSUE_NUMBER=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
          
          if [ -n "$ISSUE_NUMBER" ]; then
            echo "‚úì Found issue #$ISSUE_NUMBER in PR description"
            
            # Get issue content via GitHub API
            ISSUE_DATA=$(gh api repos/${{ github.repository }}/issues/$ISSUE_NUMBER 2>/dev/null || echo "{}")
            ISSUE_TITLE=$(echo "$ISSUE_DATA" | jq -r '.title // "Issue details"')
            ISSUE_BODY=$(echo "$ISSUE_DATA" | jq -r '.body // ""')
            
            # Save issue to file
            cat > .gemini/issue.md << 'ISSUE_EOF'
          # Issue Details
          
          ISSUE_EOF
            
            echo "## #$ISSUE_NUMBER - $ISSUE_TITLE" >> .gemini/issue.md
            echo "" >> .gemini/issue.md
            echo "$ISSUE_BODY" >> .gemini/issue.md
            
            echo "‚úì Issue saved to .gemini/issue.md"
          else
            echo "‚ö†Ô∏è  No issue number found in PR description"
            echo "# No issue linked to this PR" > .gemini/issue.md
          fi
          
          # 2. Save PR description
          cat > .gemini/pr-description.md << 'PR_DESC_EOF'
          # Pull Request Description
          
          PR_DESC_EOF
          
          echo "$PR_BODY" >> .gemini/pr-description.md
          echo "‚úì PR description saved to .gemini/pr-description.md"
          
          # 3. Generate diff
          echo "Generating diff from $BASE_SHA to $HEAD_SHA..."
          git diff "$BASE_SHA..$HEAD_SHA" > .gemini/diff.patch || {
            # Fallback if commit range doesn't work
            git diff HEAD > .gemini/diff.patch
          }
          
          DIFF_SIZE=$(wc -c < .gemini/diff.patch)
          echo "‚úì Diff generated: $DIFF_SIZE bytes"
          
          if [ $DIFF_SIZE -eq 0 ]; then
            echo "‚ö†Ô∏è  No changes detected in diff"
          fi
          
          # 4. Save list of changed files
          git diff --name-only "$BASE_SHA..$HEAD_SHA" 2>/dev/null > .gemini/changed_files.txt || {
            git diff --name-only HEAD^ HEAD > .gemini/changed_files.txt
          }
          
          CHANGED_COUNT=$(wc -l < .gemini/changed_files.txt)
          echo "‚úì Changed files: $CHANGED_COUNT files"
          
          # 5. Display what we're working with
          echo ""
          echo "üìä Materials prepared:"
          echo "  - Issue: $([ -s .gemini/issue.md ] && echo 'Yes' || echo 'No')"
          echo "  - PR description: $([ -s .gemini/pr-description.md ] && echo 'Yes' || echo 'No')"
          echo "  - Diff: $([ -s .gemini/diff.patch ] && echo 'Yes' || echo 'No')"
          echo "  - Changed files: $([ -s .gemini/changed_files.txt ] && echo 'Yes' || echo 'No')"

      # ‚≠ê STEP 5: RUN GEMINI CLI CODE REVIEW (–ì–õ–ê–í–ù–û–ï!)
      - name: Run Gemini CLI code review
        id: review
        env:
          GENAI_API_KEY: ${{ secrets.GOOGLE_AI_API_KEY || secrets.GEMINI_API_KEY }}
        run: |
          set -e
          
          if [ -z "$GENAI_API_KEY" ]; then
            echo "‚ùå GENAI_API_KEY is not set"
            echo "Please add GOOGLE_AI_API_KEY or GEMINI_API_KEY to repository secrets"
            exit 1
          fi
          
          # –ù–∞—Å—Ç—Ä–æ–∏—Ç—å API –∫–ª—é—á –¥–ª—è Gemini CLI
          export GENAI_API_KEY="$GENAI_API_KEY"
          
          echo "ü§ñ Running Gemini CLI code review with --yolo --checkpointing..."
          
          # ‚≠ê –ó–ê–ü–£–°–¢–ò–¢–¨ GENAI –° –†–ï–ñ–ò–ú–û–ú –ê–í–¢–û-–ü–†–ê–í–û–ö
          echo "üéØ Executing Gemini CLI with auto-fix capabilities..."
          
          genai --yolo --checkpointing "
# –ò–ù–°–¢–†–£–ö–¶–ò–ò –î–õ–Ø AI CODE REVIEWER

–ò—Å–ø–æ–ª—å–∑—É–π —ç—Ç—É —Å–∏—Å—Ç–µ–º—É –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é:
@.github/gemini/code-review-prompt.md

# –ö–û–ù–¢–ï–ö–°–¢ GITHUB ISSUE
@.gemini/issue.md

# –û–ü–ò–°–ê–ù–ò–ï PR
@.gemini/pr-description.md

# –ö–û–î –î–õ–Ø –ê–ù–ê–õ–ò–ó–ê –ò –ü–†–ê–í–ö–ò
@.gemini/diff.patch

# –î–ï–ô–°–¢–í–ò–Ø:
1. –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π –∫–æ–¥ –ø—Ä–æ—Ç–∏–≤ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π issue
2. –ù–∞–π–¥–∏ bugs, style issues, missing tests
3. –ü–†–ê–í–¨ –§–ê–ô–õ–´ –í –í–ï–¢–ö–ï (–∏—Å–ø–æ–ª—å–∑—É–π --yolo --checkpointing —Ä–µ–∂–∏–º)
4. –í–µ—Ä–∏—Ñ–∏—Ü–∏—Ä—É–π —á—Ç–æ –∫–æ–¥ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π
5. –í—ã–≤–µ–¥–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ JSON —Ñ–æ—Ä–º–∞—Ç–µ
" || {
            echo "‚ö†Ô∏è Gemini CLI with --yolo --checkpointing completed"
            echo "Note: Files may have been modified by AI agent"
          }
          
          echo "‚úì Gemini CLI review completed!"
          
          # –ü–æ–ª—É—á–∏—Ç—å JSON —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —à–∞–≥–∞
          echo "üìä Generating JSON summary..."
          genai --output json "
–ò—Å–ø–æ–ª—å–∑—É–π —ç—Ç—É –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é: @.github/gemini/code-review-prompt.md
–ê–Ω–∞–ª–∏–∑–∏—Ä—É–π –∫–æ–¥: @.gemini/diff.patch  
–í—ã–≤–µ–¥–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ JSON —Ñ–æ—Ä–º–∞—Ç–µ
" > .gemini/review-result.json 2>/dev/null || {
            echo "‚ö†Ô∏è Could not get JSON output, creating fallback"
            cat > .gemini/review-result.json << 'EOF'
{
  "overall_rating": "‚ö†Ô∏è REVIEW",
  "summary": "Code review completed by Gemini CLI",
  "issue_number": 0,
  "checklist_items": [],
  "issues": [],
  "improvements": ["Review completed - check files for AI modifications"],
  "files_modified": []
}
EOF
          }
          
          echo "‚úì JSON result saved to .gemini/review-result.json"

      # STEP 6: Auto-fix: Commit and push changes (if any)
      - name: Commit and push changes to PR branch
        id: commit
        if: always()
        env:
          HEAD_REF: ${{ steps.pr_context.outputs.HEAD_REF }}
        run: |
          # Check for uncommitted changes
          if git diff --quiet; then
            echo "‚úì No changes detected by AI Agent"
            echo "HAS_CHANGES=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "üîß AI Agent detected changes to commit"
          
          # Check if we have any staged changes
          git add -A
          
          if git diff --cached --quiet; then
            echo "‚úì No staged changes to commit"
            echo "HAS_CHANGES=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Configure git
          git config user.name "AI Code Review Agent"
          git config user.email "ai-review@github.local"
          
          # Get list of changed files
          CHANGED=$(git diff --cached --name-only | xargs echo "Modified files:" || echo "")
          
          # Create commit message
          COMMIT_MSG="fix: auto-improvements by Gemini CLI AI Agent

          - Code quality improvements
          - Missing tests and documentation added
          - Checklist items completed where possible
          - Code style and formatting fixes"
          
          # Commit changes
          git commit -m "$COMMIT_MSG" || {
            echo "‚ö†Ô∏è  Commit failed - no changes to commit"
            echo "HAS_CHANGES=false" >> $GITHUB_OUTPUT
            exit 0
          }
          
          echo "‚úì Changes committed"
          
          # Push to PR branch
          git push origin "$HEAD_REF" || {
            echo "‚ùå Failed to push changes"
            exit 1
          }
          
          echo "‚úì Changes pushed to origin/$HEAD_REF"
          echo "HAS_CHANGES=true" >> $GITHUB_OUTPUT
          echo "COMMIT_MSG<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMIT_MSG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # STEP 7: Post review summary to PR
      - name: Post review summary to PR
        if: always() && steps.pr_context.outputs.PR_NUMBER != '0'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            let reviewData = {};
            
            // Try to read review results from .gemini directory
            const reviewPath = '.gemini/review-result.json';
            
            if (fs.existsSync(reviewPath)) {
              try {
                const content = fs.readFileSync(reviewPath, 'utf8');
                reviewData = JSON.parse(content);
                console.log('‚úì Review data loaded successfully');
              } catch (e) {
                console.log('‚ö†Ô∏è  Could not parse review JSON:', e.message);
                reviewData = {
                  overall_rating: '‚ö†Ô∏è REVIEW',
                  summary: 'Code review completed - JSON parsing failed',
                  issues: [],
                  improvements: [],
                  checklist_items: [],
                  files_modified: []
                };
              }
            } else {
              console.log('‚ö†Ô∏è  Review result file not found');
              reviewData = {
                overall_rating: '‚ö†Ô∏è REVIEW',
                summary: 'Code review completed by Gemini CLI',
                issues: [],
                improvements: ['Review completed by AI agent'],
                checklist_items: [],
                files_modified: []
              };
            }
            
            // Build markdown comment
            let comment = `## ü§ñ AI Code Review Summary\n\n`;
            
            const prNumber = context.issue.number;
            const issueNum = reviewData.issue_number || 0;
            
            // Issue reference
            if (issueNum > 0) {
              comment += `**Issue:** #${issueNum}\n\n`;
            }
            
            // Overall rating
            const rating = reviewData.overall_rating || '‚ö†Ô∏è REVIEW';
            comment += `**Overall Rating:** ${rating}\n\n`;
            
            // Summary
            if (reviewData.summary) {
              comment += `**Summary:** ${reviewData.summary}\n\n`;
            }
            
            // Checklist items
            if (reviewData.checklist_items && reviewData.checklist_items.length > 0) {
              comment += `### ‚úÖ Checklist Status\n`;
              reviewData.checklist_items.forEach(item => {
                const icon = item.status === 'completed' ? '‚úÖ' :
                            item.status === 'incomplete' ? '‚ùå' : '‚ö†Ô∏è';
                comment += `${icon} ${item.item}`;
                if (item.reason) {
                  comment += ` - ${item.reason}`;
                }
                comment += `\n`;
              });
              comment += `\n`;
            }
            
            // Issues found
            if (reviewData.issues && reviewData.issues.length > 0) {
              comment += `### üö® Issues Found\n`;
              reviewData.issues.forEach(issue => {
                const icon = issue.severity === 'critical' ? 'üî¥' :
                            issue.severity === 'warning' ? 'üü°' : 'üîµ';
                comment += `\n${icon} **${issue.severity.toUpperCase()}** in \`${issue.file}\`\n`;
                comment += `> ${issue.message}\n`;
                if (issue.suggestion) {
                  comment += `üí° ${issue.suggestion}\n`;
                }
              });
              comment += `\n`;
            }
            
            // Improvements
            if (reviewData.improvements && reviewData.improvements.length > 0) {
              comment += `### üí° Improvements Suggested\n`;
              reviewData.improvements.forEach(imp => {
                comment += `- ${imp}\n`;
              });
              comment += `\n`;
            }
            
            // Files modified by AI
            if (reviewData.files_modified && reviewData.files_modified.length > 0) {
              comment += `### üìù Files Modified by AI Agent\n`;
              reviewData.files_modified.forEach(file => {
                comment += `- \`${file}\`\n`;
              });
              comment += `\n`;
            }
            
            // Status of AI changes
            const hasChanges = '${{ steps.commit.outputs.HAS_CHANGES }}' === 'true';
            comment += `### ‚ÑπÔ∏è AI Agent Status\n`;
            comment += `- Auto-fixes applied: ${hasChanges ? '‚úÖ Yes' : '‚ùå No'}\n`;
            if (hasChanges) {
              comment += `- Commit: auto-improvements by Gemini CLI AI Agent\n`;
            }
            comment += `\n`;
            
            // Fallback: show raw response if JSON parsing failed
            if (Object.keys(reviewData).length === 0 && reviewRaw) {
              comment += `### üìã Review Details\n`;
              comment += `\`\`\`\n`;
              comment += reviewRaw.substring(0, 2000);
              comment += `\n\`\`\`\n\n`;
            }
            
            // Footer
            comment += `---\n`;
            comment += `*Auto-generated by Gemini CLI AI Agent*\n`;
            
            // Post comment
            try {
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
              console.log('‚úì Comment posted to PR #' + context.issue.number);
            } catch (error) {
              console.log('‚ö†Ô∏è  Could not post comment:', error.message);
            }

      # STEP 9: Debug outputs
      - name: Show review results
        if: always()
        run: |
          echo "üìã Review Results:"
          echo ""
          
          if [ -f ".gemini/review-result.json" ]; then
            echo "JSON Result:"
            cat .gemini/review-result.json | jq . 2>/dev/null || cat .gemini/review-result.json
          else
            echo "‚ö†Ô∏è  No JSON result file found"
          fi
          
          echo ""
          echo "üìÅ Materials in .gemini/:"
          ls -la .gemini/ 2>/dev/null || echo "No .gemini directory found"
          
          echo ""
          echo "üìä Files Modified by AI Agent:"
          git status --porcelain || echo "No git changes detected"
          
          echo ""
          echo "üîç Current Branch:"
          git branch --show-current
          
          echo ""
          echo "‚úÖ Gemini CLI execution completed!"
