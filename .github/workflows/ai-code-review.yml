name: AI Code Review with Gemini CLI

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - main
      - develop

  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to review (optional, for manual runs)'
        required: false
        type: string

      base_ref:
        description: 'Base ref for diff if no PR (e.g., main)'
        required: false
        default: 'main'
        type: string

permissions:
  contents: write
  pull-requests: write
  checks: write

jobs:
  ai-code-review:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      # Step 1: Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ github.token }}

      # Step 2: Determine PR context
      - name: Determine PR context
        id: pr_context
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            # Automatic trigger from PR event
            PR_NUMBER=${{ github.event.pull_request.number }}
            BASE_SHA=${{ github.event.pull_request.base.sha }}
            HEAD_SHA=${{ github.event.pull_request.head.sha }}
            HEAD_REF=${{ github.event.pull_request.head.ref }}
            PR_TITLE="${{ github.event.pull_request.title }}"
            PR_BODY="${{ github.event.pull_request.body }}"
            
            echo "‚úì Triggered from PR event (auto)"
          else
            # Manual workflow_dispatch trigger
            if [ -n "${{ inputs.pr_number }}" ]; then
              # Get PR metadata from GitHub API
              PR_NUMBER="${{ inputs.pr_number }}"
              PR_DATA=$(gh api repos/${{ github.repository }}/pulls/$PR_NUMBER)
              
              PR_TITLE=$(echo "$PR_DATA" | jq -r '.title')
              PR_BODY=$(echo "$PR_DATA" | jq -r '.body // ""')
              BASE_SHA=$(echo "$PR_DATA" | jq -r '.base.sha')
              HEAD_SHA=$(echo "$PR_DATA" | jq -r '.head.sha')
              HEAD_REF=$(echo "$PR_DATA" | jq -r '.head.ref')
              
              # Checkout PR branch
              git fetch origin $HEAD_REF
              git checkout -B $HEAD_REF origin/$HEAD_REF
              
              echo "‚úì Triggered from workflow_dispatch with PR #$PR_NUMBER"
            else
              # Manual workflow_dispatch without PR - use base_ref and current HEAD
              BASE_REF="${{ inputs.base_ref }}"
              git fetch origin $BASE_REF
              
              BASE_SHA=$(git rev-parse origin/$BASE_REF)
              HEAD_SHA=$(git rev-parse HEAD)
              HEAD_REF=$(git rev-parse --abbrev-ref HEAD)
              PR_NUMBER="0"
              PR_TITLE="Manual code review on $HEAD_REF"
              PR_BODY=""
              
              echo "‚úì Triggered from workflow_dispatch without PR (comparing with $BASE_REF)"
            fi
          fi

          # Export outputs
          echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "BASE_SHA=$BASE_SHA" >> $GITHUB_OUTPUT
          echo "HEAD_SHA=$HEAD_SHA" >> $GITHUB_OUTPUT
          echo "HEAD_REF=$HEAD_REF" >> $GITHUB_OUTPUT
          echo "PR_TITLE=$PR_TITLE" >> $GITHUB_OUTPUT
          echo "PR_BODY<<EOF" >> $GITHUB_OUTPUT
          echo "$PR_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Debug output
          echo ""
          echo "üìã PR Context Determined:"
          echo "  PR_NUMBER: $PR_NUMBER"
          echo "  BASE_SHA: ${BASE_SHA:0:8}"
          echo "  HEAD_SHA: ${HEAD_SHA:0:8}"
          echo "  HEAD_REF: $HEAD_REF"
          echo "  PR_TITLE: $PR_TITLE"

      # Step 3: Setup Node.js for Gemini CLI
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      # Step 4: Install Gemini CLI
      - name: Install Gemini CLI
        run: |
          echo "üì¶ Installing Gemini CLI..."
          npm install -g @google/genai
          
          # Verify installation
          genai --version || {
            echo "‚ö†Ô∏è  npx fallback: genai not found globally, will use npx"
            npm list -g @google/genai || echo "Installing via npx approach"
          }
          
          echo "‚úì Gemini CLI ready"

      # Step 5: Prepare materials for Gemini CLI
      - name: Prepare materials for Gemini CLI
        id: prepare
        env:
          GH_TOKEN: ${{ github.token }}
          BASE_SHA: ${{ steps.pr_context.outputs.BASE_SHA }}
          HEAD_SHA: ${{ steps.pr_context.outputs.HEAD_SHA }}
          PR_NUMBER: ${{ steps.pr_context.outputs.PR_NUMBER }}
          PR_BODY: ${{ steps.pr_context.outputs.PR_BODY }}
        run: |
          set -e
          
          # Create working directory
          mkdir -p .gemini
          
          echo "üìù Preparing materials for review..."
          
          # 1. Extract issue number from PR description (format: #NUMBER or Fixes #NUMBER)
          ISSUE_NUMBER=$(echo "$PR_BODY" | grep -oE '#[0-9]+' | head -1 | tr -d '#' || echo "")
          
          echo "ISSUE_NUMBER=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
          
          if [ -n "$ISSUE_NUMBER" ]; then
            echo "‚úì Found issue #$ISSUE_NUMBER in PR description"
            
            # Get issue content via GitHub API
            ISSUE_DATA=$(gh api repos/${{ github.repository }}/issues/$ISSUE_NUMBER 2>/dev/null || echo "{}")
            ISSUE_TITLE=$(echo "$ISSUE_DATA" | jq -r '.title // "Issue details"')
            ISSUE_BODY=$(echo "$ISSUE_DATA" | jq -r '.body // ""')
            
            # Save issue to file
            cat > .gemini/issue.md << 'ISSUE_EOF'
          # Issue Details
          
          ISSUE_EOF
            
            echo "## #$ISSUE_NUMBER - $ISSUE_TITLE" >> .gemini/issue.md
            echo "" >> .gemini/issue.md
            echo "$ISSUE_BODY" >> .gemini/issue.md
            
            echo "‚úì Issue saved to .gemini/issue.md"
          else
            echo "‚ö†Ô∏è  No issue number found in PR description"
            echo "# No issue linked to this PR" > .gemini/issue.md
          fi
          
          # 2. Save PR description
          cat > .gemini/pr-description.md << 'PR_DESC_EOF'
          # Pull Request Description
          
          PR_DESC_EOF
          
          echo "$PR_BODY" >> .gemini/pr-description.md
          echo "‚úì PR description saved to .gemini/pr-description.md"
          
          # 3. Generate diff
          echo "Generating diff from $BASE_SHA to $HEAD_SHA..."
          git diff "$BASE_SHA..$HEAD_SHA" > .gemini/diff.patch || {
            # Fallback if commit range doesn't work
            git diff HEAD > .gemini/diff.patch
          }
          
          DIFF_SIZE=$(wc -c < .gemini/diff.patch)
          echo "‚úì Diff generated: $DIFF_SIZE bytes"
          
          if [ $DIFF_SIZE -eq 0 ]; then
            echo "‚ö†Ô∏è  No changes detected in diff"
          fi
          
          # 4. Save list of changed files
          git diff --name-only "$BASE_SHA..$HEAD_SHA" 2>/dev/null > .gemini/changed_files.txt || {
            git diff --name-only HEAD^ HEAD > .gemini/changed_files.txt
          }
          
          CHANGED_COUNT=$(wc -l < .gemini/changed_files.txt)
          echo "‚úì Changed files: $CHANGED_COUNT files"
          
          # 5. Display what we're working with
          echo ""
          echo "üìä Materials prepared:"
          echo "  - Issue: $([ -s .gemini/issue.md ] && echo 'Yes' || echo 'No')"
          echo "  - PR description: $([ -s .gemini/pr-description.md ] && echo 'Yes' || echo 'No')"
          echo "  - Diff: $([ -s .gemini/diff.patch ] && echo 'Yes' || echo 'No')"
          echo "  - Changed files: $([ -s .gemini/changed_files.txt ] && echo 'Yes' || echo 'No')"

      # Step 6: Run Gemini CLI code review
      - name: Run Gemini CLI code review
        id: review
        env:
          GEMINI_API_KEY: ${{ secrets.GOOGLE_AI_API_KEY || secrets.GEMINI_API_KEY }}
          ISSUE_NUMBER: ${{ steps.prepare.outputs.ISSUE_NUMBER }}
        run: |
          set -e
          
          if [ -z "$GEMINI_API_KEY" ]; then
            echo "‚ùå GEMINI_API_KEY is not set"
            echo "Please add GOOGLE_AI_API_KEY or GEMINI_API_KEY to repository secrets"
            exit 1
          fi
          
          echo "ü§ñ Running Gemini CLI code review..."
          
          # Read the system prompt
          SYSTEM_PROMPT=$(cat .github/gemini/code-review-prompt.md)
          
          # Read the materials
          ISSUE_CONTENT=$(cat .gemini/issue.md 2>/dev/null || echo "# No issue provided")
          PR_DESC=$(cat .gemini/pr-description.md 2>/dev/null || echo "No PR description")
          DIFF=$(cat .gemini/diff.patch 2>/dev/null || echo "No changes")
          CHANGED_FILES=$(cat .gemini/changed_files.txt 2>/dev/null | head -20 | xargs echo "Changed files:" || echo "No files changed")
          
          # Construct the full prompt
          FULL_PROMPT="$SYSTEM_PROMPT

          ## PR CONTEXT

          ### Issue
          $ISSUE_CONTENT

          ### PR Description
          $PR_DESC

          ### Changed Files
          $CHANGED_FILES

          ### Code Diff (truncated to first 8000 chars)
          \`\`\`diff
          ${DIFF:0:8000}
          \`\`\`

          ## TASK

          Analyze this PR and:
          1. Review code changes against the issue checklist
          2. Identify any bugs, style issues, or missing tests
          3. Suggest improvements
          4. Format response as JSON with this structure:
          {
            \"overall_rating\": \"‚úÖ APPROVE | ‚ö†Ô∏è REVIEW | ‚ùå REQUEST_CHANGES\",
            \"summary\": \"Brief summary\",
            \"issue_number\": $ISSUE_NUMBER,
            \"checklist_items\": [
              {\"item\": \"description\", \"status\": \"completed|incomplete|not_applicable\", \"reason\": \"why\"}
            ],
            \"issues\": [
              {\"severity\": \"critical|warning|info\", \"file\": \"path.py\", \"message\": \"description\", \"suggestion\": \"fix\"}
            ],
            \"improvements\": [\"suggestion1\", \"suggestion2\"],
            \"files_modified\": [\"file1.py\", \"file2.py\"]
          }"
          
          # Call Gemini API using curl (since CLI might not be fully set up)
          RESPONSE=$(curl -s -X POST \
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=$GEMINI_API_KEY" \
            -H "Content-Type: application/json" \
            -d "{
              \"contents\": [{
                \"parts\": [{
                  \"text\": \"$FULL_PROMPT\"
                }]
              }]
            }")
          
          # Extract text from response
          REVIEW_TEXT=$(echo "$RESPONSE" | jq -r '.contents[0].parts[0].text // ""' 2>/dev/null)
          
          if [ -z "$REVIEW_TEXT" ]; then
            echo "‚ùå Failed to get response from Gemini API"
            echo "Response: $RESPONSE"
            exit 1
          fi
          
          # Try to extract JSON from response
          JSON_CONTENT=$(echo "$REVIEW_TEXT" | jq . 2>/dev/null || echo "{}")
          
          if [ "$JSON_CONTENT" == "{}" ]; then
            # Try regex extraction
            JSON_CONTENT=$(echo "$REVIEW_TEXT" | grep -oP '(?<=```json).*?(?=```)' -s || echo '{}')
            if [ -z "$JSON_CONTENT" ]; then
              JSON_CONTENT=$(echo "$REVIEW_TEXT" | grep -oP '\{.*\}' -s || echo '{}')
            fi
          fi
          
          # Save review result
          echo "$JSON_CONTENT" > /tmp/review_result.json
          
          # Also save raw response
          echo "$REVIEW_TEXT" > /tmp/review_raw.txt
          
          echo "‚úì Review completed!"
          echo ""
          echo "Review saved to /tmp/review_result.json"

      # Step 7: Auto-fix: Commit and push changes (if any)
      - name: Commit and push changes to PR branch
        id: commit
        if: always()
        env:
          HEAD_REF: ${{ steps.pr_context.outputs.HEAD_REF }}
        run: |
          # Check for uncommitted changes
          if git diff --quiet; then
            echo "‚úì No changes detected by AI Agent"
            echo "HAS_CHANGES=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "üîß AI Agent detected changes to commit"
          
          # Check if we have any staged changes
          git add -A
          
          if git diff --cached --quiet; then
            echo "‚úì No staged changes to commit"
            echo "HAS_CHANGES=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Configure git
          git config user.name "AI Code Review Agent"
          git config user.email "ai-review@github.local"
          
          # Get list of changed files
          CHANGED=$(git diff --cached --name-only | xargs echo "Modified files:" || echo "")
          
          # Create commit message
          COMMIT_MSG="fix: auto-improvements by Gemini CLI AI Agent

          - Code quality improvements
          - Missing tests and documentation added
          - Checklist items completed where possible
          - Code style and formatting fixes"
          
          # Commit changes
          git commit -m "$COMMIT_MSG" || {
            echo "‚ö†Ô∏è  Commit failed - no changes to commit"
            echo "HAS_CHANGES=false" >> $GITHUB_OUTPUT
            exit 0
          }
          
          echo "‚úì Changes committed"
          
          # Push to PR branch
          git push origin "$HEAD_REF" || {
            echo "‚ùå Failed to push changes"
            exit 1
          }
          
          echo "‚úì Changes pushed to origin/$HEAD_REF"
          echo "HAS_CHANGES=true" >> $GITHUB_OUTPUT
          echo "COMMIT_MSG<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMIT_MSG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # Step 8: Post review summary to PR
      - name: Post review summary to PR
        if: always() && steps.pr_context.outputs.PR_NUMBER != '0'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            let reviewData = {};
            let reviewRaw = '';
            
            // Try to read review results
            const reviewPath = '/tmp/review_result.json';
            const rawPath = '/tmp/review_raw.txt';
            
            if (fs.existsSync(reviewPath)) {
              try {
                const content = fs.readFileSync(reviewPath, 'utf8');
                reviewData = JSON.parse(content);
              } catch (e) {
                console.log('‚ö†Ô∏è  Could not parse review JSON:', e.message);
              }
            }
            
            if (fs.existsSync(rawPath)) {
              reviewRaw = fs.readFileSync(rawPath, 'utf8');
            }
            
            // Build markdown comment
            let comment = `## ü§ñ AI Code Review Summary\n\n`;
            
            const prNumber = context.issue.number;
            const issueNum = reviewData.issue_number || 0;
            
            // Issue reference
            if (issueNum > 0) {
              comment += `**Issue:** #${issueNum}\n\n`;
            }
            
            // Overall rating
            const rating = reviewData.overall_rating || '‚ö†Ô∏è REVIEW';
            comment += `**Overall Rating:** ${rating}\n\n`;
            
            // Summary
            if (reviewData.summary) {
              comment += `**Summary:** ${reviewData.summary}\n\n`;
            }
            
            // Checklist items
            if (reviewData.checklist_items && reviewData.checklist_items.length > 0) {
              comment += `### ‚úÖ Checklist Status\n`;
              reviewData.checklist_items.forEach(item => {
                const icon = item.status === 'completed' ? '‚úÖ' :
                            item.status === 'incomplete' ? '‚ùå' : '‚ö†Ô∏è';
                comment += `${icon} ${item.item}`;
                if (item.reason) {
                  comment += ` - ${item.reason}`;
                }
                comment += `\n`;
              });
              comment += `\n`;
            }
            
            // Issues found
            if (reviewData.issues && reviewData.issues.length > 0) {
              comment += `### üö® Issues Found\n`;
              reviewData.issues.forEach(issue => {
                const icon = issue.severity === 'critical' ? 'üî¥' :
                            issue.severity === 'warning' ? 'üü°' : 'üîµ';
                comment += `\n${icon} **${issue.severity.toUpperCase()}** in \`${issue.file}\`\n`;
                comment += `> ${issue.message}\n`;
                if (issue.suggestion) {
                  comment += `üí° ${issue.suggestion}\n`;
                }
              });
              comment += `\n`;
            }
            
            // Improvements
            if (reviewData.improvements && reviewData.improvements.length > 0) {
              comment += `### üí° Improvements Suggested\n`;
              reviewData.improvements.forEach(imp => {
                comment += `- ${imp}\n`;
              });
              comment += `\n`;
            }
            
            // Files modified by AI
            if (reviewData.files_modified && reviewData.files_modified.length > 0) {
              comment += `### üìù Files Modified by AI Agent\n`;
              reviewData.files_modified.forEach(file => {
                comment += `- \`${file}\`\n`;
              });
              comment += `\n`;
            }
            
            // Status of AI changes
            const hasChanges = '${{ steps.commit.outputs.HAS_CHANGES }}' === 'true';
            comment += `### ‚ÑπÔ∏è AI Agent Status\n`;
            comment += `- Auto-fixes applied: ${hasChanges ? '‚úÖ Yes' : '‚ùå No'}\n`;
            if (hasChanges) {
              comment += `- Commit: auto-improvements by Gemini CLI AI Agent\n`;
            }
            comment += `\n`;
            
            // Fallback: show raw response if JSON parsing failed
            if (Object.keys(reviewData).length === 0 && reviewRaw) {
              comment += `### üìã Review Details\n`;
              comment += `\`\`\`\n`;
              comment += reviewRaw.substring(0, 2000);
              comment += `\n\`\`\`\n\n`;
            }
            
            // Footer
            comment += `---\n`;
            comment += `*Auto-generated by Gemini CLI AI Agent*\n`;
            
            // Post comment
            try {
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
              console.log('‚úì Comment posted to PR #' + context.issue.number);
            } catch (error) {
              console.log('‚ö†Ô∏è  Could not post comment:', error.message);
            }

      # Step 9: Debug outputs
      - name: Show review results
        if: always()
        run: |
          echo "üìã Review Results:"
          echo ""
          
          if [ -f "/tmp/review_result.json" ]; then
            echo "JSON Result:"
            cat /tmp/review_result.json | jq . 2>/dev/null || cat /tmp/review_result.json
          else
            echo "‚ö†Ô∏è  No JSON result file found"
          fi
          
          echo ""
          echo "Raw Response:"
          if [ -f "/tmp/review_raw.txt" ]; then
            head -50 /tmp/review_raw.txt
          else
            echo "‚ö†Ô∏è  No raw response file found"
          fi
